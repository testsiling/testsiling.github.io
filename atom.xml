<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BUG DEVELOPER</title>
  
  <subtitle>Debugging the world</subtitle>
  <link href="http://testsiling.github.io/atom.xml" rel="self"/>
  
  <link href="http://testsiling.github.io/"/>
  <updated>2021-01-16T03:38:21.000Z</updated>
  <id>http://testsiling.github.io/</id>
  
  <author>
    <name>Siling Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Some Useful Tricks in Python 3</title>
    <link href="http://testsiling.github.io/2021/01/15/python2/"/>
    <id>http://testsiling.github.io/2021/01/15/python2/</id>
    <published>2021-01-16T03:38:21.000Z</published>
    <updated>2021-01-16T03:38:21.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>f-string</li><li>:= Walrus Operator</li></ul><a id="more"></a><h2 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Celine&#x27;</span></span><br><span class="line">score = <span class="number">123.4567</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">score</span> + <span class="title">x</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="params"><span class="string">f&#x27;name = <span class="subst">&#123;name&#125;</span>, score = <span class="subst">&#123;score:<span class="number">.3</span>f&#125;</span>&#x27;</span></span>)  # <span class="title">python</span> 3.6+</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="params"><span class="string">f&#x27;<span class="subst">&#123;name = &#125;</span>, <span class="subst">&#123;score = :<span class="number">.3</span>f&#125;</span>&#x27;</span></span>)  #<span class="title">python</span> 3.8+</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="params"><span class="string">f&#x27;<span class="subst">&#123;score = &#125;</span>, <span class="subst">&#123;plus(<span class="number">100</span>) = &#125;</span>&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure><p>I usually use the first one, just found the new feature in after 3.8.</p><h2 id=""><a href="#" class="headerlink" title=":="></a>:=</h2><p>:= Assignment Expressions (after 3.8)</p><h3 id="scenario-1-local-variable"><a href="#scenario-1-local-variable" class="headerlink" title="scenario 1: local variable"></a>scenario 1: local variable</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>] * <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># call len(a) twice</span></span><br><span class="line"><span class="keyword">if</span> len(a) &gt; <span class="number">10</span>:</span><br><span class="line">    print(<span class="string">f&#x27;list too long, <span class="subst">&#123;len(a)&#125;</span> elements&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call len(a) once</span></span><br><span class="line">n = len(a)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">10</span>:</span><br><span class="line">    print(<span class="string">f&#x27;list too long, <span class="subst">&#123;n&#125;</span> elements&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call len(a) once and assign it to x</span></span><br><span class="line"><span class="comment"># needs parenthesis, := piority lower than other operator</span></span><br><span class="line"><span class="keyword">if</span> (x := len(a)) &gt; <span class="number">10</span>:</span><br><span class="line">    print(<span class="string">f&#x27;list too long, <span class="subst">&#123;x&#125;</span> elements&#x27;</span>)</span><br><span class="line">    print(<span class="string">f&#x27;list too long, <span class="subst">&#123;x&#125;</span> elements&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="scanrio-2-while-loop"><a href="#scanrio-2-while-loop" class="headerlink" title="scanrio 2: while loop"></a>scanrio 2: while loop</h3><p>read a string flow till the end.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># basic</span></span><br><span class="line">f1 = io.StringIO(<span class="string">&#x27;123456789&#x27;</span>)</span><br><span class="line">x1 = f1.read(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">while</span> x1:</span><br><span class="line">    print(x1)</span><br><span class="line">    x1 = f1.read(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># better</span></span><br><span class="line">f2 = io.StringIO(<span class="string">&#x27;123456789&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> (x2 := f2.read(<span class="number">2</span>)) != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">    print(x2)</span><br></pre></td></tr></table></figure></p><h3 id="scenario-3-in-list-comprehension"><a href="#scenario-3-in-list-comprehension" class="headerlink" title="scenario 3: in list comprehension"></a>scenario 3: in list comprehension</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">targets = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>]</span><br><span class="line">my = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Melon&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print all element in my list match in target list</span></span><br><span class="line"><span class="comment"># call lower() twice</span></span><br><span class="line">l1 = [f.lower() <span class="keyword">for</span> f <span class="keyword">in</span> my <span class="keyword">if</span> f.lower() <span class="keyword">in</span> targets]</span><br><span class="line">print(l1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call lower() once</span></span><br><span class="line">l2 = [f <span class="keyword">for</span> fruit <span class="keyword">in</span> my <span class="keyword">if</span> (f:= fruit.lower()) <span class="keyword">in</span> targets]</span><br><span class="line">print(l2)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;f-string&lt;/li&gt;
&lt;li&gt;:= Walrus Operator&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Design (1)</title>
    <link href="http://testsiling.github.io/2021/01/12/al-design-1/"/>
    <id>http://testsiling.github.io/2021/01/12/al-design-1/</id>
    <published>2021-01-13T02:40:35.000Z</published>
    <updated>2021-01-13T02:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Data Structure Design Problem Set (1)</p><ul><li>146.LRU Cache</li><li>284.Peeking Iterator</li><li>341.Flatten Nested List Iterator</li><li>295.Find Median from Data Stream</li></ul><a id="more"></a><h2 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a>146. LRU Cache</h2><p>Design Least Recently Used (LRU) Cache<br>Use double-linked list as cache, disconnect the old node and reconnect it to the tail of the list when <code>get</code> an value. add new node to the tail and drop the first (the least used) node if exceed capacity.<br>use a dictionary to log {key: node}<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k=<span class="number">0</span>, v=<span class="number">0</span></span>):</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.v = v</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: int</span>):</span></span><br><span class="line">        self.head = Node()</span><br><span class="line">        self.tail = Node()</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.dict = &#123;&#125;</span><br><span class="line">        self.cap = capacity</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_remove</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="comment"># remove the least used node</span></span><br><span class="line">        node.prev.next = node.next</span><br><span class="line">        node.next.prev = node.prev</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        last = self.tail.prev</span><br><span class="line">        self.tail.prev = node</span><br><span class="line">        last.next = node</span><br><span class="line">        node.next = self.tail</span><br><span class="line">        node.prev = last</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># move recent used node to tail</span></span><br><span class="line">        node = self.dict[key]</span><br><span class="line">        self._remove(node)</span><br><span class="line">        self._add(node)</span><br><span class="line">        <span class="keyword">return</span> node.v</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: int, value: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># remove the existed key first, we will add new anyway</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dict:</span><br><span class="line">            node = self.dict[key]</span><br><span class="line">            self._remove(node)</span><br><span class="line">            <span class="keyword">del</span> self.dict[key]</span><br><span class="line">        </span><br><span class="line">        node = Node(key, value)</span><br><span class="line">        self._add(node)</span><br><span class="line">        self.dict[key] = node</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(self.dict) &gt; self.cap:</span><br><span class="line">            least = self.head.next</span><br><span class="line">            self._remove(least)</span><br><span class="line">            <span class="keyword">del</span> self.dict[least.k]</span><br></pre></td></tr></table></figure></p><h2 id="284-Peeking-Iterator"><a href="#284-Peeking-Iterator" class="headerlink" title="284. Peeking Iterator"></a>284. Peeking Iterator</h2><p>My initial idea was create a one-way linked list, or initialize a normal list, which is too easy. But if so, it lose the meaning as iterator. Then I second thought, I don’t even need a list, I just need a buffer for the peak value.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekingIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, iterator</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        :type iterator: Iterator</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._iterator = iterator</span><br><span class="line">        self._peak = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._peak <span class="keyword">and</span> self._iterator.hasNext():</span><br><span class="line">            self._peak = self._iterator.next()</span><br><span class="line">        <span class="keyword">return</span> self._peak</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._peak:</span><br><span class="line">            peak = self._peak</span><br><span class="line">            self._peak = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> peak</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self._iterator.next()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._peak:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self._iterator.hasNext()</span><br></pre></td></tr></table></figure></p><h2 id="341-Flatten-Nested-List-Iterator"><a href="#341-Flatten-Nested-List-Iterator" class="headerlink" title="341. Flatten Nested List Iterator"></a>341. Flatten Nested List Iterator</h2><p>Flatten nested list in init. Use deque to faster pop the first element.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nestedList: [NestedInteger]</span>):</span></span><br><span class="line">        self.ls = deque()</span><br><span class="line">        self.flatten(nestedList)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, nestedList</span>):</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> nestedList:</span><br><span class="line">            <span class="keyword">if</span> l.isInteger():</span><br><span class="line">                self.ls.append(l.getInteger())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.flatten(l.getList())      </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.ls.popleft() <span class="keyword">if</span> self.hasNext <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.ls) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h2 id="295-Find-Median-from-Data-Stream"><a href="#295-Find-Median-from-Data-Stream" class="headerlink" title="295. Find Median from Data Stream"></a>295. Find Median from Data Stream</h2><p>Dividing data into 2 heaps (length as equal as possible):</p><ul><li>Use max heap to store a chunk of smaller elements</li><li>Use min heap to store another chunk of larger elements.<br>Reference:<br><a href="https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg">https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.small = []  <span class="comment"># store smaller data, maxHeap</span></span><br><span class="line">        self.large = []  <span class="comment"># store larger data, minHeap</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">self, num: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># insert into large</span></span><br><span class="line">        <span class="keyword">if</span> len(self.small) &gt;= len(self.large):</span><br><span class="line">            heapq.heappush(self.small, -num)</span><br><span class="line">            heapq.heappush(self.large, -heapq.heappop(self.small))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self.large, num)</span><br><span class="line">            heapq.heappush(self.small, -heapq.heappop(self.large))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span>(<span class="params">self</span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.small) &gt; len(self.large):</span><br><span class="line">            <span class="keyword">return</span>  -self.small[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> len(self.large) &gt; len(self.small):</span><br><span class="line">            <span class="keyword">return</span> self.large[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># even len</span></span><br><span class="line">            <span class="keyword">return</span> (-self.small[<span class="number">0</span>] + self.large[<span class="number">0</span>]) / <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Data Structure Design Problem Set (1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;146.LRU Cache&lt;/li&gt;
&lt;li&gt;284.Peeking Iterator&lt;/li&gt;
&lt;li&gt;341.Flatten Nested List Iterator&lt;/li&gt;
&lt;li&gt;295.Find Median from Data Stream&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Data Structure" scheme="http://testsiling.github.io/tags/Data-Structure/"/>
    
    <category term="Design" scheme="http://testsiling.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Dynamic Programming (3) - Buy &amp; Sell Stock!</title>
    <link href="http://testsiling.github.io/2021/01/10/al-dp-3/"/>
    <id>http://testsiling.github.io/2021/01/10/al-dp-3/</id>
    <published>2021-01-10T19:54:15.000Z</published>
    <updated>2021-01-10T19:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Best-Time-to-Buy-and-Sell-Stock-Problem-Set"><a href="#Best-Time-to-Buy-and-Sell-Stock-Problem-Set" class="headerlink" title="[Best Time to Buy and Sell Stock] Problem Set"></a>[Best Time to Buy and Sell Stock] Problem Set</h1><p>Leetcode Dynamic Programming Problem Set (3)</p><ul><li>121.Best Time to Buy and Sell Stock</li><li>122.Best Time to Buy and Sell Stock II</li><li>123.Best Time to Buy and Sell Stock III</li><li>188.Best Time to Buy and Sell Stock IV</li><li>309.Best Time to Buy and Sell Stock with Cooldown</li><li>714.Best Time to Buy and Sell Stock with Transaction Fee</li></ul><a id="more"></a><p>There are 3 options in each trade day: <strong>buy, sell, hold</strong><br>We can use a 3d array to log all situations:<br><code>dp[i][k][1 or 0]</code> = <code>the maximum profit at the end of the i-th day with at most k transactions and with 0 or 1 stock in our hand AFTER taking the action</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># either always haven&#x27;t got stock, or sold a stock. </span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># either I kept the existed stock, or bought one.</span></span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Base case：dp[-1] means before day 0, haven&#x27;t start yet.</span></span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">0</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">1</span>] = float(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Recurrence relations:</span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h2><p>k = 1.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    buy = prices[<span class="number">0</span>]</span><br><span class="line">    profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">        buy = min(prices[i], buy)</span><br><span class="line">        profit = max(profit, prices[i] - buy)</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure></p><h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h2><p>k = inf<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">    last_buy = -prices[<span class="number">0</span>]  <span class="comment"># have one stock, either bought or kept</span></span><br><span class="line">    last_sell = <span class="number">0</span>  <span class="comment"># have no stock, either sold or kept</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">        cur_buy = max(last_buy, last_sell - prices[i])</span><br><span class="line">        cur_sell = max(last_sell, last_buy+ prices[i])</span><br><span class="line">        last_buy = cur_buy</span><br><span class="line">        last_sell = cur_sell</span><br><span class="line">    <span class="keyword">return</span> last_sell</span><br></pre></td></tr></table></figure></p><h2 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a>123. Best Time to Buy and Sell Stock III</h2><p>k = 2<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">    <span class="comment"># last_k_numberOfStock</span></span><br><span class="line">    gain_1_1, gain_2_1 = float(<span class="string">&#x27;-inf&#x27;</span>), float(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    gain_1_0, gain_2_0 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        gain_2_0 = max(gain_2_0, gain_2_1 + p)</span><br><span class="line">        gain_2_1 = max(gain_2_1, gain_1_0 - p)</span><br><span class="line">        gain_1_0 = max(gain_1_0, gain_1_1 + p)</span><br><span class="line">        gain_1_1 = max(gain_1_1, -p)</span><br><span class="line">    <span class="keyword">return</span> gain_2_0</span><br></pre></td></tr></table></figure></p><h2 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. Best Time to Buy and Sell Stock IV"></a>188. Best Time to Buy and Sell Stock IV</h2><p>k = inf<br>The most general case. Very hard to understand<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, k: int, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span> <span class="keyword">or</span> <span class="keyword">not</span> k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = len(prices)</span><br><span class="line">        k = min(k, n // <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        stock0 = [<span class="number">0</span>] * (k + <span class="number">1</span>)</span><br><span class="line">        stock1 = [float(<span class="string">&#x27;-inf&#x27;</span>)] * (k + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                stock0[j] = max(stock0[j], stock1[j] + price)</span><br><span class="line">                stock1[j] = max(stock1[j], stock0[j<span class="number">-1</span>] - price)</span><br><span class="line">        <span class="keyword">return</span> stock0[k]</span><br></pre></td></tr></table></figure></p><h2 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a>309. Best Time to Buy and Sell Stock with Cooldown</h2><p>k = inf + cooldown<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    buy = float(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    sell = <span class="number">0</span></span><br><span class="line">    prev_sell = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        temp = sell</span><br><span class="line">        sell = max(sell, buy + p)</span><br><span class="line">        buy = max(buy, prev_sell - p)</span><br><span class="line">        prev_sell = temp</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sell</span><br></pre></td></tr></table></figure></p><h2 id="714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="714. Best Time to Buy and Sell Stock with Transaction Fee"></a>714. Best Time to Buy and Sell Stock with Transaction Fee</h2><p>The same as <strong>Best Time to Buy and Sell Stock II</strong>, just need to deduct fee from profit.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int], fee: int</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    buy = float(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    sell = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        sell = max(sell, buy + p - fee)</span><br><span class="line">        buy = max(buy, sell - p)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sell</span><br></pre></td></tr></table></figure></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems">Most consistent ways of dealing with the series of stock problems</a></p></li><li><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75927/share-my-thinking-process">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75927/share-my-thinking-process</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Best-Time-to-Buy-and-Sell-Stock-Problem-Set&quot;&gt;&lt;a href=&quot;#Best-Time-to-Buy-and-Sell-Stock-Problem-Set&quot; class=&quot;headerlink&quot; title=&quot;[Best Time to Buy and Sell Stock] Problem Set&quot;&gt;&lt;/a&gt;[Best Time to Buy and Sell Stock] Problem Set&lt;/h1&gt;&lt;p&gt;Leetcode Dynamic Programming Problem Set (3)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;121.Best Time to Buy and Sell Stock&lt;/li&gt;
&lt;li&gt;122.Best Time to Buy and Sell Stock II&lt;/li&gt;
&lt;li&gt;123.Best Time to Buy and Sell Stock III&lt;/li&gt;
&lt;li&gt;188.Best Time to Buy and Sell Stock IV&lt;/li&gt;
&lt;li&gt;309.Best Time to Buy and Sell Stock with Cooldown&lt;/li&gt;
&lt;li&gt;714.Best Time to Buy and Sell Stock with Transaction Fee&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://testsiling.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Dynamic Programming (2)</title>
    <link href="http://testsiling.github.io/2021/01/06/al-dp-2/"/>
    <id>http://testsiling.github.io/2021/01/06/al-dp-2/</id>
    <published>2021-01-07T02:26:49.000Z</published>
    <updated>2021-01-07T02:26:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Dynamic Programming Problem Collection (2)</p><ul><li>322.Coin Change</li><li>55.Jump Game</li><li>62.Unique Paths</li><li>300.Longest Increasing Subsequence</li><li>91.Decode Way</li></ul><a id="more"></a><h2 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h2><p>for example coins = [1,2,5], x = 11<br>Three cases for selecting the last coin:</p><ol><li>the last coin is $1, f(x) = f(x - 1) + 1</li><li>the last coin is $2, f(x) = f(x - 2) + 1</li><li>the last coin is $5, f(x) = f(x - 5) + 1</li></ol><p>Hense, <code>f(x) = min(f(x - 1), f(x - 2), f(x - 5)) + 1</code><br>we can use recursion to eaisly get the global optimized result, with lot of redandunt calculation (TLE)<br>Or we can pre-calculate and save f(0) ~ f(x), to avoid repeating calculation.<br><code>f(0) = 0</code> is the base case. <code>x - coin &lt; 0</code> is invalid, for instance, f(1) = -1, no result. </p><h3 id="Bottom-up"><a href="#Bottom-up" class="headerlink" title="Bottom up"></a>Bottom up</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[int], amount: int</span>) -&gt; int:</span></span><br><span class="line">    dp = [amount + <span class="number">1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> i - coin &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[i] = min(dp[i], <span class="number">1</span> + dp[i - coin])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> dp[amount] == amount + <span class="number">1</span> <span class="keyword">else</span> dp[amount]</span><br></pre></td></tr></table></figure><h3 id="Top-down"><a href="#Top-down" class="headerlink" title="Top down"></a>Top down</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[int], amount: int</span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">amount</span>):</span></span><br><span class="line">        <span class="keyword">if</span> amount <span class="keyword">in</span> found:</span><br><span class="line">            <span class="keyword">return</span> found[amount]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        res = float(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            cur = change(amount - coin)</span><br><span class="line">            <span class="keyword">if</span> cur != <span class="number">-1</span>:</span><br><span class="line">                res = min(res, <span class="number">1</span> + cur)</span><br><span class="line">        </span><br><span class="line">        found[amount] = res <span class="keyword">if</span> res != float(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    found = &#123;&#125;</span><br><span class="line">    change(amount)</span><br><span class="line">    <span class="keyword">return</span> found[amount] <span class="keyword">if</span> amount != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a>55. Jump Game</h2><p>This is a top-down solution. start the the second last element, if <code>nums[i] + i &gt;= last element</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">    last = len(nums) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># from the second last element</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i) &gt;= last:</span><br><span class="line">            last = i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> last == <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h2><p>If you draw the board, for example m = 3, n = 7, then fill in the number of ways you can get to that a cell, the right-bottom coner is thr right resule. A bottom-up solution.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 1, 1,  1,  1,  1</span><br><span class="line">1, 2, 3, 4,  5,  6,  7</span><br><span class="line">1, 3, 6, 10, 15, 21, 28</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: int, n: int</span>) -&gt; int:</span></span><br><span class="line">    paths = [[<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            paths[r][c] = paths[r - <span class="number">1</span>][c] + paths[r][c - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> paths[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h2 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h2><p>I don’t think anyone can really thinkof the greedy + binary search solution. Probaly excepting the author, and pro poker players?<br>Anyway, here’s the DP solution. Time complexity is O(n^2). dp table logs the LIS ending with <code>nums[i]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">    dp = [<span class="number">1</span>] * len(nums)</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        res = max(res, dp[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="91-Decode-Way"><a href="#91-Decode-Way" class="headerlink" title="91. Decode Way"></a>91. Decode Way</h2><p>Recursion with memorization. If you draw down the decision tree, that will be pretty straightward.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[s]</span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        ways = decode(s[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">if</span> int(s[:<span class="number">2</span>]) &lt;= <span class="number">26</span>:</span><br><span class="line">            ways += decode(s[<span class="number">2</span>:])</span><br><span class="line">        memo[s] = ways</span><br><span class="line">        <span class="keyword">return</span> ways</span><br><span class="line">    </span><br><span class="line">    memo = &#123;<span class="string">&#x27;&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> decode(s)</span><br></pre></td></tr></table></figure></p><p>DP<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    dp = [<span class="number">0</span>] * len(s)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] += s[<span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    dp[<span class="number">1</span>] += <span class="number">10</span> &lt;= int(s[:<span class="number">2</span>]) &lt;= <span class="number">26</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(s)):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># single digit</span></span><br><span class="line">        <span class="keyword">if</span> s[i] != <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># double digits</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">10</span> &lt;= int(s[i - <span class="number">1</span> : i + <span class="number">1</span>]) &lt;= <span class="number">26</span>:</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Dynamic Programming Problem Collection (2)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;322.Coin Change&lt;/li&gt;
&lt;li&gt;55.Jump Game&lt;/li&gt;
&lt;li&gt;62.Unique Paths&lt;/li&gt;
&lt;li&gt;300.Longest Increasing Subsequence&lt;/li&gt;
&lt;li&gt;91.Decode Way&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://testsiling.github.io/tags/Dynamic-Programming/"/>
    
    <category term="Greedy" scheme="http://testsiling.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Two Pointers (2)</title>
    <link href="http://testsiling.github.io/2021/01/03/al-two-pointers-2/"/>
    <id>http://testsiling.github.io/2021/01/03/al-two-pointers-2/</id>
    <published>2021-01-04T00:47:23.000Z</published>
    <updated>2021-01-04T00:47:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Two pointers problem set (2)</p><ul><li>11.Container With Most Water</li><li>532.K-diff Pairs in an Array</li></ul><p>N Sum problem set:</p><ul><li>1.Two Sum</li><li>167.Two Sum II - Input array is sorted</li><li>15.3Sum</li><li>16.3Sum Closest</li><li>18.4Sum</li></ul><a id="more"></a><h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: List[int]</span>) -&gt; int:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(height) - <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        cur = (right - left) * min(height[left], height[right])</span><br><span class="line">        res = max(cur, res)</span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="532-K-diff-Pairs-in-an-Array"><a href="#532-K-diff-Pairs-in-an-Array" class="headerlink" title="532. K-diff Pairs in an Array"></a>532. K-diff Pairs in an Array</h2><h3 id="Two-Pointers"><a href="#Two-Pointers" class="headerlink" title="Two Pointers"></a>Two Pointers</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPairs</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; int:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    l, r = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> r &lt; len(nums) <span class="keyword">and</span> l &lt; len(nums):</span><br><span class="line">        <span class="keyword">if</span> l == r <span class="keyword">or</span> (nums[r] - nums[l]) &lt; k:</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[r] - nums[l] &gt; k:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; len(nums) <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h3><p>Much eaiser than two pointers solution, time is O(n)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPairs</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; int:</span></span><br><span class="line">    counter = Counter(nums)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> counter:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">and</span> counter[x] &gt; <span class="number">1</span>:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> x + k <span class="keyword">in</span> counter:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="N-Sum-Problem"><a href="#N-Sum-Problem" class="headerlink" title="N Sum Problem:"></a>N Sum Problem:</h2><h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h3><p>Unsort array, use hash map<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; List[int]:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">return</span> [dic[n], i]</span><br><span class="line">        dic[target - n] = i</span><br></pre></td></tr></table></figure></p><h3 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="167. Two Sum II - Input array is sorted"></a>167. Two Sum II - Input array is sorted</h3><p>Sorted array use 2 pointers<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: List[int], target: int</span>) -&gt; List[int]:</span></span><br><span class="line">    lo, hi = <span class="number">0</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        cur = numbers[lo] + numbers[hi]</span><br><span class="line">        <span class="keyword">if</span> cur == target:</span><br><span class="line">            <span class="keyword">return</span> (lo + <span class="number">1</span>, hi + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> cur &lt; target:</span><br><span class="line">            lo += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hi -= <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h3 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h3><h4 id="Two-Pointers-1"><a href="#Two-Pointers-1" class="headerlink" title="Two Pointers"></a>Two Pointers</h4><p>Remember to skip duplicate result.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums, target, start</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        lo, hi = start, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            cur = nums[lo] + nums[hi]</span><br><span class="line">            <span class="keyword">if</span> cur &lt; target:</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]:</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur &gt; target:</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]:</span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([nums[lo], nums[hi]])</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]:</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]:</span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(nums) - <span class="number">2</span>:</span><br><span class="line">        two_sums = twoSum(nums, -nums[i], i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> two_sums:</span><br><span class="line">            res.append([nums[i]] + s)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums) - <span class="number">2</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h4 id="Hashmap-1"><a href="#Hashmap-1" class="headerlink" title="Hashmap"></a>Hashmap</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums, target, res</span>):</span></span><br><span class="line">        seen = set()</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">            x = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> seen:</span><br><span class="line">                res.append([-target, nums[i], x])</span><br><span class="line">                <span class="keyword">while</span> i + <span class="number">1</span> &lt; len(nums) <span class="keyword">and</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            seen.add(nums[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># all following nums are greater than 0</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> nums[i - <span class="number">1</span>] != nums[i]:</span><br><span class="line">            twoSum(nums[i + <span class="number">1</span>:], -nums[i], res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h3><p>Similar with 3Sum<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums, target, start</span>):</span></span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        diff = float(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        lo, hi = start, len(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            cur = nums[lo] + nums[hi]</span><br><span class="line">            <span class="keyword">if</span> cur == target:</span><br><span class="line">                <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line">            cur_diff = abs(target - cur)</span><br><span class="line">            <span class="keyword">if</span> cur_diff &lt; diff:</span><br><span class="line">                res = cur</span><br><span class="line">                diff = cur_diff</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur &lt; target:</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    nums.sort()</span><br><span class="line">    res = <span class="literal">None</span></span><br><span class="line">    diff = float(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">        cur_sum = nums[i] + twoSum(nums, target - nums[i], i + <span class="number">1</span>)</span><br><span class="line">        cur_diff = abs(target - cur_sum)</span><br><span class="line">        <span class="keyword">if</span> cur_diff == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> cur_sum</span><br><span class="line">        <span class="keyword">if</span> cur_diff &lt; diff:</span><br><span class="line">            res = cur_sum</span><br><span class="line">            diff = cur_diff</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h3><p>The same as 3 sum.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target, start</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        lo, hi = start, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            cur = nums[lo] + nums[hi]</span><br><span class="line">            <span class="keyword">if</span> cur &lt; target:</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]:</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur &gt; target:</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]:</span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([nums[lo], nums[hi]])</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]:</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]:</span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[int], target, start, </span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        i = start</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums) - <span class="number">2</span>:</span><br><span class="line">            two_sums = self.twoSum(nums, target - nums[i], i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> two_sums:</span><br><span class="line">                res.append([nums[i]] + s)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; len(nums) - <span class="number">2</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums) - <span class="number">3</span>:</span><br><span class="line">            triples = self.threeSum(nums, target - nums[i], i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> triples:</span><br><span class="line">                res.append([nums[i]] + t)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; len(nums) - <span class="number">3</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>But, we can generlize it to a N Sum function</p><h3 id="N-Sum"><a href="#N-Sum" class="headerlink" title="N Sum"></a>N Sum</h3><p>The list <code>nums</code> should sort outside of the function, or else the list will resort in every recursion.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nSum</span>(<span class="params">self, nums, target, n, start=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="comment"># nums.sort()  # assume the nums is sorted.</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2 sum is base case.</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">or</span> len(nums) &lt; n:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            lo, hi = start, len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">                cur = nums[lo] + nums[hi]</span><br><span class="line">                <span class="keyword">if</span> cur &lt; target:</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]:</span><br><span class="line">                        lo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> cur &gt; target:</span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]:</span><br><span class="line">                        hi -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[lo], nums[hi]])</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]:</span><br><span class="line">                        lo += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]:</span><br><span class="line">                        hi -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        i = start</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums) - (n - <span class="number">1</span>):</span><br><span class="line">            nsum = self.nSum(nums, target - nums[i], n - <span class="number">1</span>, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> nsum:</span><br><span class="line">                res.append([nums[i]] + s)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; len(nums) - (n - <span class="number">1</span>) <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>So, for the four sum problem, just simplly call<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">return</span> self.nSum(nums, target, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Two pointers problem set (2)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;11.Container With Most Water&lt;/li&gt;
&lt;li&gt;532.K-diff Pairs in an Array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;N Sum problem set:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.Two Sum&lt;/li&gt;
&lt;li&gt;167.Two Sum II - Input array is sorted&lt;/li&gt;
&lt;li&gt;15.3Sum&lt;/li&gt;
&lt;li&gt;16.3Sum Closest&lt;/li&gt;
&lt;li&gt;18.4Sum&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Two Pointers" scheme="http://testsiling.github.io/tags/Two-Pointers/"/>
    
    <category term="Sliding windows" scheme="http://testsiling.github.io/tags/Sliding-windows/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Two Pointers (1) - Sliding Window</title>
    <link href="http://testsiling.github.io/2021/01/01/al-two-pointers-1/"/>
    <id>http://testsiling.github.io/2021/01/01/al-two-pointers-1/</id>
    <published>2021-01-01T18:14:47.000Z</published>
    <updated>2021-01-01T18:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Two pointers problem set (1) - Sliding Window</p><ul><li>76.Minimum Window Substring</li><li>567.Permutation in String</li><li>438.Find All Anagrams in a String</li><li>3.Longest Substring Without Repeating Characters</li><li>239.Sliding Window Maximum</li></ul><a id="more"></a><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find string t in string s</span></span><br><span class="line"><span class="keyword">from</span> collection <span class="keyword">import</span> Counter, defaultdict</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sliding_window</span>(<span class="params">s, t</span>):</span></span><br><span class="line">need = Counter(t)</span><br><span class="line">valid = <span class="number">0</span></span><br><span class="line">left = right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> right &lt; len(s):</span><br><span class="line">c = s[right]</span><br><span class="line">right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># do something</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> window needs shrink:</span><br><span class="line">d = s[left]</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line"><span class="comment"># do something</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a>76. Minimum Window Substring</h2><ol><li>Extend right pointer until all characters found</li><li>Log smallest window</li><li>Shrink left pointer until found the next valid window</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minWindow</span>(<span class="params">self, s: str, t: str</span>) -&gt; str:</span></span><br><span class="line">    needs = dict(Counter(t))</span><br><span class="line">    left = right = <span class="number">0</span></span><br><span class="line">    counter = len(t)</span><br><span class="line">    min_len = float(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># search [left. right)</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; len(s):</span><br><span class="line">        </span><br><span class="line">        c = s[right]</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> needs:</span><br><span class="line">        <span class="comment"># is a valid character</span></span><br><span class="line">        needs[c] -= <span class="number">1</span></span><br><span class="line">            counter -= needs[c] &gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> counter:</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># update res</span></span><br><span class="line">            <span class="keyword">if</span> (right - left) &lt; min_len:</span><br><span class="line">                min_len = right - left</span><br><span class="line">                res = s[left: right]</span><br><span class="line">            </span><br><span class="line">            c = s[left]</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> needs:</span><br><span class="line">                needs[c] += <span class="number">1</span></span><br><span class="line">                counter += needs[c] &gt; <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="567-Permutation-in-String"><a href="#567-Permutation-in-String" class="headerlink" title="567. Permutation in String"></a>567. Permutation in String</h2><p>True criteria is <code>len(s1) == window size</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span>(<span class="params">self, s1: str, s2: str</span>) -&gt; bool:</span></span><br><span class="line">    </span><br><span class="line">    needs = Counter(s1)</span><br><span class="line">    counter = len(s1)</span><br><span class="line">    </span><br><span class="line">    left = right = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> right &lt; len(s2):</span><br><span class="line">        </span><br><span class="line">        c = s2[right]</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> needs:</span><br><span class="line">            needs[c] -= <span class="number">1</span></span><br><span class="line">            counter -= needs[c] &gt;= <span class="number">0</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> counter:</span><br><span class="line">            <span class="keyword">if</span> right - left == len(s1):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            c = s2[left]</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> needs:</span><br><span class="line">                needs[c] += <span class="number">1</span></span><br><span class="line">                counter += needs[c] &gt; <span class="number">0</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><h2 id="438-Find-All-Anagrams-in-a-String"><a href="#438-Find-All-Anagrams-in-a-String" class="headerlink" title="438. Find All Anagrams in a String"></a>438. Find All Anagrams in a String</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s: str, p: str</span>) -&gt; List[int]:</span></span><br><span class="line">    needs = Counter(p)</span><br><span class="line">    counter = len(p)</span><br><span class="line">    left = right = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> right &lt; len(s):</span><br><span class="line">        c = s[right]</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> needs:</span><br><span class="line">            needs[c] -= <span class="number">1</span></span><br><span class="line">            counter -= needs[c] &gt;= <span class="number">0</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># is a valid window</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> counter:</span><br><span class="line">            c = s[left]</span><br><span class="line">            <span class="keyword">if</span> (right - left) == len(p):</span><br><span class="line">                res.append(left)</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> needs:</span><br><span class="line">                needs[c] += <span class="number">1</span></span><br><span class="line">                counter += needs[c] &gt; <span class="number">0</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">    </span><br><span class="line">    cur = defaultdict(int)</span><br><span class="line">    left = right = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> right &lt; len(s):</span><br><span class="line">        cur[s[right]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur[s[right]] &gt; <span class="number">1</span>:</span><br><span class="line">            cur[s[left]] -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        res = max(res, right - left)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure><h2 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a>239. Sliding Window Maximum</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; List[int]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">window_push</span>(<span class="params">n</span>):</span></span><br><span class="line">        <span class="comment"># delete all element less than n</span></span><br><span class="line">        <span class="keyword">while</span> window <span class="keyword">and</span> window[<span class="number">-1</span>] &lt; n:</span><br><span class="line">            window.pop()</span><br><span class="line">        window.append(n)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">window_get_max</span>():</span></span><br><span class="line">        <span class="keyword">return</span> window[<span class="number">0</span>] <span class="keyword">if</span> window <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">window_pop</span>(<span class="params">n</span>):</span></span><br><span class="line">        <span class="keyword">return</span> window.popleft() <span class="keyword">if</span> window <span class="keyword">and</span> n == window[<span class="number">0</span>] <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    window = deque([])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        window_push(n)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># generate res when i &gt;= k - 1</span></span><br><span class="line">            res.append(window_get_max())</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># remove left</span></span><br><span class="line">            window_pop(nums[i - k + <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Two pointers problem set (1) - Sliding Window&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;76.Minimum Window Substring&lt;/li&gt;
&lt;li&gt;567.Permutation in String&lt;/li&gt;
&lt;li&gt;438.Find All Anagrams in a String&lt;/li&gt;
&lt;li&gt;3.Longest Substring Without Repeating Characters&lt;/li&gt;
&lt;li&gt;239.Sliding Window Maximum&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Two Pointers" scheme="http://testsiling.github.io/tags/Two-Pointers/"/>
    
    <category term="Sliding windows" scheme="http://testsiling.github.io/tags/Sliding-windows/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Binary Search (2)</title>
    <link href="http://testsiling.github.io/2020/12/30/al-binary-search-2/"/>
    <id>http://testsiling.github.io/2020/12/30/al-binary-search-2/</id>
    <published>2020-12-31T00:12:56.000Z</published>
    <updated>2020-12-31T00:12:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Binary Search Problem Set (2) - Hard</p><ul><li>410.Split Array Largest Sum</li></ul><a id="more"></a><h2 id="410-Split-Array-Largest-Sum"><a href="#410-Split-Array-Largest-Sum" class="headerlink" title="410. Split Array Largest Sum"></a>410. Split Array Largest Sum</h2><p>min largest sum in range: <code>[max(nums), sum(nums) + 1)</code><br>Basic idea is directly search the correct answer.</p><p>Given upper bound [max_sum], calculate the number of subarray that nums need to split into [cnt]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if cnt &gt; m:  # given max_sum is too small</span><br><span class="line">    lo &#x3D; max_sum + 1</span><br><span class="line">else:</span><br><span class="line">    hi &#x3D; max_sum</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitArray</span>(<span class="params">self, nums: List[int], m: int</span>) -&gt; int:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitable</span>(<span class="params">max_sum</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        split nums into k groups, sum of each group &lt;= max_sum</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            cur_sum += n</span><br><span class="line">            <span class="keyword">if</span> cur_sum &gt; max_sum:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                cur_sum = n</span><br><span class="line">                <span class="keyword">if</span> cnt &gt; m:  <span class="comment"># max_sum too small</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    lo = max(nums)</span><br><span class="line">    hi = sum(nums) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        max_sum = lo + (hi - lo ) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> splitable(max_sum):</span><br><span class="line">            lo = max_sum + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hi = max_sum</span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Binary Search Problem Set (2) - Hard&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;410.Split Array Largest Sum&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Binary Search" scheme="http://testsiling.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Binary Search (1)</title>
    <link href="http://testsiling.github.io/2020/12/29/al-binary-search-1/"/>
    <id>http://testsiling.github.io/2020/12/29/al-binary-search-1/</id>
    <published>2020-12-29T20:07:05.000Z</published>
    <updated>2020-12-29T20:07:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>Classic binary search scenarios are find a number, and find boundaries.<br>Leetcode Binary Search Problem Set (1) - Medium</p><ul><li>278.First Bad Version</li><li>33.Search in Rotated Sorted Array</li><li>1283.Find the Smallest Divisor Given a Threshold</li><li>875.Koko Eating Bananas</li><li>1011.Capacity To Ship Packages Within D Days</li><li>981.Time Based Key-Value Store<a id="more"></a></li></ul><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = ...</span><br><span class="line">    <span class="keyword">while</span> ...:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = ...</span><br><span class="line">    <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure><ul><li><em>Using <strong>elif</strong> instead of <strong>else</strong> in binary search can show more details, which is better for beginner to debug.</em></li><li><em><code>left + (right - left) / 2</code> is the same as <code>(right + left) / 2</code>, is avoiding int overflow. Python int won’t overflow though.</em></li></ul><h3 id="Find-a-number"><a href="#Find-a-number" class="headerlink" title="Find a number"></a>Find a number</h3><p>Search interval <strong>[left, right]</strong>, <code>left == right + 1</code> is the terminal criteria, which is an empty interval.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums, target</span>):</span></span><br><span class="line"></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums) - <span class="number">1</span>  <span class="comment"># the last element</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line"></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">        <span class="comment"># search[mid + 1, right]</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># search [left, mid - 1]</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="Find-Left-Boundary"><a href="#Find-Left-Boundary" class="headerlink" title="Find Left Boundary"></a>Find Left Boundary</h3><p>Search <code>[left, right)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_left_bound</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line"></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p>Shrink right bound to get the </p><h3 id="Find-Right-Boundary"><a href="#Find-Right-Boundary" class="headerlink" title="Find Right Boundary"></a>Find Right Boundary</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_right_bound</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line"></span><br><span class="line">        mid = left + (right - right) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="278-First-Bad-Version"><a href="#278-First-Bad-Version" class="headerlink" title="278. First Bad Version"></a>278. First Bad Version</h2><p>Finding the left bound of bad version interval<br>[G, G, G, G, G, G, G, B, B, B] =&gt; serch =&gt; [B, B, B]</p><p>The left pointer should point to the first bad version.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left = <span class="number">1</span></span><br><span class="line">    right = n</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isBadVersion(mid):</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure></p><h2 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. Search in Rotated Sorted Array</h2><p>Use binary search 2 times: </p><ol><li>find pivot (actually is find left bound)</li><li>find target number. </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; int:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> nums[left] &gt; nums[right]:</span><br><span class="line">        <span class="comment"># search pivot in [left, right)</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line"></span><br><span class="line">        p = left</span><br><span class="line">        <span class="comment"># search left</span></span><br><span class="line">        <span class="keyword">if</span> target &gt;= nums[<span class="number">0</span>]:</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = p - <span class="number">1</span></span><br><span class="line">        <span class="comment"># search right</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = p</span><br><span class="line">            right = len(nums) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1283-Find-the-Smallest-Divisor-Given-a-Threshold"><a href="#1283-Find-the-Smallest-Divisor-Given-a-Threshold" class="headerlink" title="1283. Find the Smallest Divisor Given a Threshold"></a>1283. Find the Smallest Divisor Given a Threshold</h2><p>divisor range: <em>[1, max(nums)]</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallestDivisor</span>(<span class="params">self, nums: List[int], threshold: int</span>) -&gt; int:</span></span><br><span class="line">    lo = <span class="number">1</span></span><br><span class="line">    hi = max(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = lo + (hi - lo) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> sum([ceil(n / mid) <span class="keyword">for</span> n <span class="keyword">in</span> nums]) &gt; threshold:</span><br><span class="line">            <span class="comment"># divisor too small</span></span><br><span class="line">            lo = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hi = mid</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure></p><h2 id="875-Koko-Eating-Bananas"><a href="#875-Koko-Eating-Bananas" class="headerlink" title="875. Koko Eating Bananas"></a>875. Koko Eating Bananas</h2><p>Typical find a number problem.<br>When jump out of the loop, left == right + 1, is the max number KOKO should eat.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span>(<span class="params">self, piles: List[int], H: int</span>) -&gt; int:</span></span><br><span class="line">    left = <span class="number">1</span></span><br><span class="line">    right = max(piles)  <span class="comment"># 1 pile / h</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        cur = sum([ceil(p / mid) <span class="keyword">for</span> p <span class="keyword">in</span> piles])</span><br><span class="line">        <span class="keyword">if</span> cur == H:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> cur &gt; H:</span><br><span class="line">            <span class="comment"># need less time, eat more banana each time</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="comment"># left == right + 1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure></p><h2 id="1011-Capacity-To-Ship-Packages-Within-D-Days"><a href="#1011-Capacity-To-Ship-Packages-Within-D-Days" class="headerlink" title="1011. Capacity To Ship Packages Within D Days"></a>1011. Capacity To Ship Packages Within D Days</h2><p>Left bound: max -&gt; as least can move the heaviest item<br>Right bound: sum -&gt; move all in one day<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shipWithinDays</span>(<span class="params">self, weights: List[int], D: int</span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_min_days</span>(<span class="params">weights, cap</span>):</span></span><br><span class="line">        day, cur = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> weights:</span><br><span class="line">            <span class="keyword">if</span> cur + w &gt; cap:</span><br><span class="line">                day += <span class="number">1</span></span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">            cur += w</span><br><span class="line">        <span class="keyword">return</span> day   </span><br><span class="line">    </span><br><span class="line">    left = max(weights)</span><br><span class="line">    right = sum(weights)</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        day = get_min_days(weights, mid)</span><br><span class="line">        <span class="keyword">if</span> day &gt; D:</span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># load more each day</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure></p><h2 id="981-Time-Based-Key-Value-Store"><a href="#981-Time-Based-Key-Value-Store" class="headerlink" title="981. Time Based Key-Value Store"></a>981. Time Based Key-Value Store</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.keymap = defaultdict(list)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, key: str, value: str, timestamp: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.keymap[key].append((timestamp, value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: str, timestamp: int</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.keymap:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        values = self.keymap[key]</span><br><span class="line">        <span class="keyword">if</span> timestamp &lt; values[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> timestamp &gt;= values[<span class="number">-1</span>][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> values[<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># find right bound</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(values)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            stamp, value = values[mid]</span><br><span class="line">            <span class="keyword">if</span> stamp == timestamp:</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            <span class="keyword">elif</span> stamp &lt; timestamp:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> values[left - <span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Classic binary search scenarios are find a number, and find boundaries.&lt;br&gt;Leetcode Binary Search Problem Set (1) - Medium&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;278.First Bad Version&lt;/li&gt;
&lt;li&gt;33.Search in Rotated Sorted Array&lt;/li&gt;
&lt;li&gt;1283.Find the Smallest Divisor Given a Threshold&lt;/li&gt;
&lt;li&gt;875.Koko Eating Bananas&lt;/li&gt;
&lt;li&gt;1011.Capacity To Ship Packages Within D Days&lt;/li&gt;
&lt;li&gt;981.Time Based Key-Value Store</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Binary Search" scheme="http://testsiling.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Backtracking (2)</title>
    <link href="http://testsiling.github.io/2020/12/28/al-backtracking-2/"/>
    <id>http://testsiling.github.io/2020/12/28/al-backtracking-2/</id>
    <published>2020-12-28T16:19:32.000Z</published>
    <updated>2020-12-28T16:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode backtracking problem collection (2) - Hard</p><ul><li>51.N-Queens</li><li>37.Sudoku Solver</li></ul><a id="more"></a><h2 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a>51. N-Queens</h2><p>For this problem, the trickiest part for me is how to store diagonals.<br>check this <a href="https://www.youtube.com/watch?v=Xa-yETqFNEQ">video</a><br>use 2 array to index dale and hill diagonals, both length are <script type="math/tex">n * 2 - 1</script></p><p>Hill Diagonals: idx = row + col<br>0    1    2    3    4<br>1    2    3    4    5<br>2    3    4    5    6<br>3    4    5    6    7<br>4    5    6    7    8</p><p>Dale Diagonals: idx = row - col</p><p>0    -1    -2    -3    -4<br>1    0    -1    -2    -3<br>2    1    0    -1    -2<br>3    2    1    0    -1<br>4    3    2    1    0</p><p>Use <code>updateBoard(r, c, is_put)</code> to update private variables.<br>Bacause Python string cannot update element by index (need to slice), so store board in 2d array, then melt the array into string whtn solution found.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: int</span>) -&gt; List[List[str]]:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">available</span>(<span class="params">r, c</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> cols[c] <span class="keyword">and</span> <span class="keyword">not</span> dale[r - c] <span class="keyword">and</span> <span class="keyword">not</span> hill[r + c]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateBoard</span>(<span class="params">r, c, is_put</span>):</span></span><br><span class="line">        cols[c] = is_put</span><br><span class="line">        dale[r - c] = is_put</span><br><span class="line">        hill[r + c] = is_put</span><br><span class="line">        board[r][c] = <span class="string">&#x27;Q&#x27;</span> <span class="keyword">if</span> is_put <span class="keyword">else</span> <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getBoard</span>(<span class="params">board</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;&#x27;</span>.join(x) <span class="keyword">for</span> x <span class="keyword">in</span> board]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> r == n:</span><br><span class="line">            res.append(getBoard(board))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> available(r, c):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            updateBoard(r, c, <span class="number">1</span>)</span><br><span class="line">            backtrack(r + <span class="number">1</span>)</span><br><span class="line">            updateBoard(r, c, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    cols = [<span class="number">0</span>] * n</span><br><span class="line">    dale = [<span class="number">0</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">    hill = [<span class="number">0</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">    board = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    res = []</span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a>37. Sudoku Solver</h2><p>First, this one is really hard. Unlike the n-queen problem, indexing cubes is easy. But Desidning backtrack and how to end the track is pretty hard.<br>For indexing, I just assign an array from 0 - 9, 10 space to log the fill in number. Just ignore the 0.<br>For grids, draw it down on a paper then you will find in order to get</p><p>0, 1, 2,<br>3, 4, 5,<br>6, 7, 8</p><p>can be converted from</p><p>0, 1, 2<br>1, 2, 3<br>2, 3, 4</p><p>which is generate by <em>row // 3 + col // 3</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span>(<span class="params">self, board: List[List[str]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateBoard</span>(<span class="params">r, c, n, is_fill</span>):</span></span><br><span class="line">        board[r][c] = str(n) <span class="keyword">if</span> is_fill <span class="keyword">else</span> <span class="string">&#x27;.&#x27;</span></span><br><span class="line">        rows[r][n] = is_fill</span><br><span class="line">        cols[c][n] = is_fill</span><br><span class="line">        grids[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][n] = is_fill</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">available</span>(<span class="params">r, c, n</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (rows[r][n] <span class="keyword">or</span> cols[c][n] <span class="keyword">or</span> grids[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][n])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">r, c</span>):</span></span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> backtrack(r + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> board[r][c] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> backtrack(r, c+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> available(r, c, n):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            updateBoard(r, c, n, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> backtrack(r, c + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            updateBoard(r, c, n, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    rows = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">    cols = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">    grids = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]  <span class="comment"># idx = row // 3 * 3 + col // 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># initial rows, cols, and grids</span></span><br><span class="line">    <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board):</span><br><span class="line">        <span class="keyword">for</span> j, n <span class="keyword">in</span> enumerate(row):</span><br><span class="line">            <span class="keyword">if</span> n != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                updateBoard(i, j, int(n), <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://zxi.mytechroad.com/blog/searching/leetcode-37-sudoku-solver/">http://zxi.mytechroad.com/blog/searching/leetcode-37-sudoku-solver/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode backtracking problem collection (2) - Hard&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;51.N-Queens&lt;/li&gt;
&lt;li&gt;37.Sudoku Solver&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Backtracking" scheme="http://testsiling.github.io/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Backtracking (1)</title>
    <link href="http://testsiling.github.io/2020/12/27/al-backtracking-1/"/>
    <id>http://testsiling.github.io/2020/12/27/al-backtracking-1/</id>
    <published>2020-12-27T15:46:12.000Z</published>
    <updated>2020-12-27T15:46:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Backtracking">Backtracking</a> is a general algorithm for finding all (or some) solutions to some computational problems.</p><p>Leetcode backtracking problem collection (1)</p><ul><li>46.Permutations</li><li>78.Subsets</li><li>77.Combinations</li><li>39.Combination Sum</li><li>22.Generate Parentheses<a id="more"></a></li></ul><h2 id="Difference-between-backtracking-and-DFS"><a href="#Difference-between-backtracking-and-DFS" class="headerlink" title="Difference between backtracking and DFS:"></a>Difference between backtracking and DFS:</h2><p>Backtracking is an algorithem, DFS is a specific form of backtracking related to searching tree structures.<br>DFS handles an explicit tree.While Backtracking handles an implicit tree.</p><h2 id="How-to-backtrack"><a href="#How-to-backtrack" class="headerlink" title="How to backtrack?"></a>How to backtrack?</h2><p>Backtracking actually is searching a decision tree. Three keys:</p><ol><li>path: decisions you made</li><li>choices: remaining options</li><li>terminal criteria: reach the end of decision tree.</li></ol><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">path, choices</span>):</span></span><br><span class="line">    <span class="keyword">if</span> terminal criteria:</span><br><span class="line">        res.append(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        make decision</span><br><span class="line">        backtracking(path, choices)</span><br><span class="line">        cancel choose</span><br></pre></td></tr></table></figure><h2 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h2><p>Technically backtracking is brute force, it will exhaust all possible solutions. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums, path</span>):</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == len(path):</span><br><span class="line">            res.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> path:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            backtrack(nums, path + [n])</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    backtrack(nums, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h2><p>pre-order search.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, path</span>):</span></span><br><span class="line">        res.append(path)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">            backtrack(i + <span class="number">1</span>, path + [nums[i]])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    backtrack(<span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h2><p>The same as finding subsets, but only attach path when length hit k.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: int, k: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, path</span>):</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == k:</span><br><span class="line">            res.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, n + <span class="number">1</span>):</span><br><span class="line">            backtrack(i + <span class="number">1</span>, path + [i])</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    backtrack(<span class="number">1</span>, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, path, cur</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cur &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> cur == target:</span><br><span class="line">            res.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">            n = nums[i]</span><br><span class="line">            backtrack(i, path + [n], cur + n)</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    backtrack(<span class="number">0</span>, [], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h2><p>use <code>left</code> and <code>right</code> to log reamining number of bracket. Remaining right should always greater or equal to left.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n: int</span>) -&gt; List[str]:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">left, right, path</span>):</span></span><br><span class="line">        <span class="comment"># right bracket should more than left</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; left <span class="keyword">or</span> left &lt; <span class="number">0</span> <span class="keyword">or</span> right &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> right == <span class="number">0</span> <span class="keyword">and</span> left == <span class="number">0</span>:</span><br><span class="line">            res.append(path)</span><br><span class="line">        backtrack(left - <span class="number">1</span>, right, path + <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        backtrack(left, right - <span class="number">1</span>, path + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    backtrack(n, n, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://stackoverflow.com/questions/1294720/whats-the-difference-between-backtracking-and-depth-first-search">https://stackoverflow.com/questions/1294720/whats-the-difference-between-backtracking-and-depth-first-search</a></li><li><a href="https://leetcode.com/discuss/general-discussion/136503/what-is-difference-between-backtracking-and-depth-first-search">https://leetcode.com/discuss/general-discussion/136503/what-is-difference-between-backtracking-and-depth-first-search</a></li><li><a href="https://en.wikipedia.org/wiki/Backtracking">https://en.wikipedia.org/wiki/Backtracking</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Backtracking&quot;&gt;Backtracking&lt;/a&gt; is a general algorithm for finding all (or some) solutions to some computational problems.&lt;/p&gt;
&lt;p&gt;Leetcode backtracking problem collection (1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;46.Permutations&lt;/li&gt;
&lt;li&gt;78.Subsets&lt;/li&gt;
&lt;li&gt;77.Combinations&lt;/li&gt;
&lt;li&gt;39.Combination Sum&lt;/li&gt;
&lt;li&gt;22.Generate Parentheses</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Backtracking" scheme="http://testsiling.github.io/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Tree (3)</title>
    <link href="http://testsiling.github.io/2020/12/26/al-tree-3/"/>
    <id>http://testsiling.github.io/2020/12/26/al-tree-3/</id>
    <published>2020-12-26T21:27:33.000Z</published>
    <updated>2020-12-26T21:27:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Tree problem collection (3)</p><ul><li>99.Recover Binary Search Tree</li><li>94.Binary Tree Inorder Traversal</li><li>116.Populating Next Right Pointers in Each Node</li><li>114.Flatten Binary Tree to Linked List</li><li>654.Maximum Binary Tree</li><li>106.Construct Binary Tree from Inorder and Postorder Traversal</li></ul><a id="more"></a><p>Inorder (Left, Root, Right)<br>Preorder (Root, Left, Right)<br>Postorder (Left, Right, Root)</p><h2 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99. Recover Binary Search Tree"></a>99. Recover Binary Search Tree</h2><p>In-order tranversal in a Binary Search Tree should get an ascending array. So when <script type="math/tex">Node_i < Node_{i-1}</script> means <script type="math/tex">Node_i</script> is the error node. It should swao with either <script type="math/tex">Node_{i-1}</script> or another error node if found.<br>x, y are pointers of error nodes, <em>pre</em> is used to log the previous node val. <em>node.val</em> shoule always less than <em>pre.val</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findError</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x, y, pre</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        findError(node.left)</span><br><span class="line">        <span class="keyword">if</span> pre <span class="keyword">and</span> node.val &lt; pre.val:</span><br><span class="line">            y = node</span><br><span class="line">            <span class="comment"># 1st error</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">                x = pre</span><br><span class="line">            <span class="comment"># 2nd error</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        pre = node</span><br><span class="line">        findError(node.right)</span><br><span class="line">    </span><br><span class="line">    x = y = pre = <span class="literal">None</span></span><br><span class="line">    findError(root)</span><br><span class="line">    x.val, y.val = y.val, x.val</span><br></pre></td></tr></table></figure></p><h2 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h2><p>Classic in-order search: left - root-right<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">nonlocal</span> res</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        traversal(root.left)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        traversal(root.right)</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    traversal(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a>116. Populating Next Right Pointers in Each Node</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># connect local left, right</span></span><br><span class="line">    <span class="keyword">if</span> root.left:</span><br><span class="line">        root.left.next = root.right</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">and</span> root.next:</span><br><span class="line">        root.right.next = root.next.left</span><br><span class="line">    self.connect(root.left)</span><br><span class="line">    self.connect(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="BFS-deque"><a href="#BFS-deque" class="headerlink" title="BFS / deque"></a>BFS / deque</h3><p>using Deque<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    q = deque([root])</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        size = len(q)</span><br><span class="line">        <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> size &gt; <span class="number">1</span>: <span class="comment">## not the right most:</span></span><br><span class="line">                node.next = q[<span class="number">0</span>]</span><br><span class="line">            size -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">                q.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p><p>Or BFS with improvement, get rid of the deque, use the next pointer.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    cur  = root</span><br><span class="line">    next = root.left</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> next :</span><br><span class="line">        cur.left.next = cur.right</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># not the right-most node</span></span><br><span class="line">        <span class="keyword">if</span> cur.next:</span><br><span class="line">            cur.right.next = cur.next.left</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># go to the next level</span></span><br><span class="line">            <span class="comment"># start from the left most element</span></span><br><span class="line">            cur = next</span><br><span class="line">            next = cur.left</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p><h2 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a>114. Flatten Binary Tree to Linked List</h2><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><p>post-order, flatten left, then flatten right, move left child to right and append the original right child to the end of new right child<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self.flatten(root.left)</span><br><span class="line">    self.flatten(root.right)</span><br><span class="line">    </span><br><span class="line">    right = root.right</span><br><span class="line">    left = root.left</span><br><span class="line">    </span><br><span class="line">    root.left = <span class="literal">None</span></span><br><span class="line">    root.right = left</span><br><span class="line">    </span><br><span class="line">    p = root</span><br><span class="line">    <span class="keyword">while</span> p.right:</span><br><span class="line">        p = p.right</span><br><span class="line">    p.right = right</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p><h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> root:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># find rightest element</span></span><br><span class="line">            p = root.left</span><br><span class="line">            <span class="keyword">while</span> p.right:</span><br><span class="line">                p = p.right</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># move right child to left.right</span></span><br><span class="line">            p.right = root.right</span><br><span class="line">            <span class="comment"># move left child to right</span></span><br><span class="line">            root.right = root.left</span><br><span class="line">            root.left = <span class="literal">None</span></span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure><h2 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a>654. Maximum Binary Tree</h2><p>Classic recursion<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    val = max(nums)</span><br><span class="line">    i = nums.index(val)</span><br><span class="line">    root = TreeNode(val)</span><br><span class="line">    root.left = self.constructMaximumBinaryTree(nums[:i])</span><br><span class="line">    root.right = self.constructMaximumBinaryTree(nums[i + <span class="number">1</span>: ])</span><br><span class="line">    <span class="keyword">return</span> root  </span><br></pre></td></tr></table></figure></p><h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h2><p>Pretty straightforward solution, but not the best!<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[int], postorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    val = postorder[<span class="number">-1</span>]</span><br><span class="line">    root = TreeNode(val)</span><br><span class="line">    </span><br><span class="line">    i = inorder.index(val)</span><br><span class="line">    in_left = inorder[:i]</span><br><span class="line">    in_right = inorder[i + <span class="number">1</span>:]</span><br><span class="line">    </span><br><span class="line">    post_left = postorder[:len(in_left)]</span><br><span class="line">    post_right = postorder[len(in_left): <span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    root.left = self.buildTree(in_left, post_left)</span><br><span class="line">    root.right = self.buildTree(in_right, post_right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><br>Finding index is O(n). Slicing array is O(k), k = slicing size. And extra space. Overall time and extra space is O(n^2)<br>So, to avoid finding index and slicing, use hash map<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[int], postorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        </span><br><span class="line">    dic = &#123;v: i <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">lo, hi</span>):</span></span><br><span class="line">        <span class="keyword">if</span> lo &gt; hi:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = TreeNode(postorder.pop())</span><br><span class="line">        i = dic[node.val]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># poping from post order, so should construct right child first</span></span><br><span class="line">        node.right = build(i + <span class="number">1</span>, hi)</span><br><span class="line">        node.left = build(lo, i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">0</span>, len(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>And LC105 can be imporved in similar way.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Tree problem collection (3)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;99.Recover Binary Search Tree&lt;/li&gt;
&lt;li&gt;94.Binary Tree Inorder Traversal&lt;/li&gt;
&lt;li&gt;116.Populating Next Right Pointers in Each Node&lt;/li&gt;
&lt;li&gt;114.Flatten Binary Tree to Linked List&lt;/li&gt;
&lt;li&gt;654.Maximum Binary Tree&lt;/li&gt;
&lt;li&gt;106.Construct Binary Tree from Inorder and Postorder Traversal&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Data Structure" scheme="http://testsiling.github.io/tags/Data-Structure/"/>
    
    <category term="Tree" scheme="http://testsiling.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Data Structure Cheat Sheet</title>
    <link href="http://testsiling.github.io/2020/12/26/data-strcture-cheatsheet/"/>
    <id>http://testsiling.github.io/2020/12/26/data-strcture-cheatsheet/</id>
    <published>2020-12-26T19:40:42.000Z</published>
    <updated>2020-12-26T19:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Basically, there’re two ways to store data strctures: <strong>array</strong> and <strong>linked list</strong>.<br>All other data strctures, such as queue, stack, graph, hashmap, tree, heap, etc, all can be implemented by array and linked list.</p><a id="more"></a><p>In python, <strong>list = array</strong> is implemented by dynamic array, when it used up the original assigned space, it will point to new sapce.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t ob_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */</span></span><br><span class="line">    PyObject **ob_item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ob_item contains space for &#x27;allocated&#x27; elements.  The number</span></span><br><span class="line"><span class="comment">     * currently in use is ob_size.</span></span><br><span class="line"><span class="comment">     * Invariants:</span></span><br><span class="line"><span class="comment">     *     0 &lt;= ob_size &lt;= allocated</span></span><br><span class="line"><span class="comment">     *     len(list) == ob_size</span></span><br><span class="line"><span class="comment">     *     ob_item == NULL implies ob_size == allocated == 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure><p>The array itself stores a list of of pointers. Therefore, while using list, need to cautious to some traps like: during initialization, all pointers are pointing to the same list<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls = [[]] * <span class="number">5</span></span><br><span class="line">ls[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line">print(ls)  <span class="comment">#[[1], [1], [1], [1], [1]]</span></span><br></pre></td></tr></table></figure><br>Also, time for popping the last element is O(1), but popping intermediate is O(n). </p><h2 id="Tranverseal"><a href="#Tranverseal" class="headerlink" title="Tranverseal"></a>Tranverseal</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><h3 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, next=None</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"><span class="comment"># iterative</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tranverse</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">        <span class="comment"># do something</span></span><br><span class="line">        p = p.next</span><br><span class="line"></span><br><span class="line"><span class="comment"># recursive</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tranverse</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    tranverse(head.next)</span><br></pre></td></tr></table></figure><h3 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=None, right=None</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tranverse</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># pre-order</span></span><br><span class="line">    tranverse(root.left)</span><br><span class="line">    <span class="comment"># in-order</span></span><br><span class="line">    tranverse(root.right)</span><br><span class="line">    <span class="comment"># post-order</span></span><br></pre></td></tr></table></figure><h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice:"></a>Practice:</h3><ul><li>124.Binary Tree Maximum Path Sum</li><li>105.Construct Binary Tree from Preorder and Inorder Traversal</li><li>94.Binary Tree Inorder Traversal</li><li>106.Construct Binary Tree from Inorder and Postorder Traversal</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Basically, there’re two ways to store data strctures: &lt;strong&gt;array&lt;/strong&gt; and &lt;strong&gt;linked list&lt;/strong&gt;.&lt;br&gt;All other data strctures, such as queue, stack, graph, hashmap, tree, heap, etc, all can be implemented by array and linked list.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Data Structure" scheme="http://testsiling.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Stack (1)</title>
    <link href="http://testsiling.github.io/2020/12/16/al-stack-1/"/>
    <id>http://testsiling.github.io/2020/12/16/al-stack-1/</id>
    <published>2020-12-17T03:06:09.000Z</published>
    <updated>2020-12-17T03:06:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Stack Problem Collection (1)</p><ul><li>20.Valid Parentheses</li><li>1249.Minimum Remove to Make Valid Parentheses</li><li>394.Decode String</li><li>1209.Remove All Adjacent Duplicates in String II</li><li>739.Daily Temperatures</li><li><ol><li>Simplify Path</li></ol></li></ul><a id="more"></a><h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: str</span>) -&gt; bool:</span></span><br><span class="line">    right = &#123;</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="comment"># left bracket</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> right:</span><br><span class="line">            stack.append(c)</span><br><span class="line">        <span class="comment"># right bracket</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack.pop() != right[c]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><h2 id="1249-Minimum-Remove-to-Make-Valid-Parentheses"><a href="#1249-Minimum-Remove-to-Make-Valid-Parentheses" class="headerlink" title="1249. Minimum Remove to Make Valid Parentheses"></a>1249. Minimum Remove to Make Valid Parentheses</h2><ul><li>for right bracket, must match to an existed left bracket, or remove it.</li><li>for left bracket, log its index<br>After scan the whole string, remove open left bracket<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span>(<span class="params">self, s: str</span>) -&gt; str:</span></span><br><span class="line">    open_left = []</span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            res += c</span><br><span class="line">            open_left.append(len(res) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> open_left:</span><br><span class="line">                res += c</span><br><span class="line">                open_left.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += c</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(open_left):</span><br><span class="line">        res = res[:i] + res[i + <span class="number">1</span>: ]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ul><h2 id="394-Decode-String"><a href="#394-Decode-String" class="headerlink" title="394. Decode String"></a>394. Decode String</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decodeString</span>(<span class="params">self, s: str</span>) -&gt; str:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            repeat = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                x = stack.pop()</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># found substring</span></span><br><span class="line">                <span class="keyword">if</span> x == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                    <span class="comment"># find number</span></span><br><span class="line">                    num = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                    <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].isdigit():</span><br><span class="line">                        num = stack.pop() + num</span><br><span class="line">                    num = int(num)</span><br><span class="line">                    repeat = repeat * int(num)</span><br><span class="line">                    stack.append(repeat)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                repeat = x + repeat</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(c)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure><h2 id="1209-Remove-All-Adjacent-Duplicates-in-String-II"><a href="#1209-Remove-All-Adjacent-Duplicates-in-String-II" class="headerlink" title="1209. Remove All Adjacent Duplicates in String II"></a>1209. Remove All Adjacent Duplicates in String II</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, s: str, k: int</span>) -&gt; str:</span></span><br><span class="line">    stack = []  <span class="comment"># (element, cnt)</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">and</span> c == stack[<span class="number">-1</span>][<span class="number">0</span>]:</span><br><span class="line">            cnt = stack[<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            stack.append((c, cnt))</span><br><span class="line">            <span class="keyword">if</span> cnt == k:</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">                    stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append((c, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> stack])</span><br></pre></td></tr></table></figure><h2 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739. Daily Temperatures"></a>739. Daily Temperatures</h2><p>use index to calculate days<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, T: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">    stack = []  <span class="comment"># temp, index</span></span><br><span class="line">    warmer = [<span class="number">0</span>] * len(T)</span><br><span class="line">    <span class="keyword">for</span> i, temp <span class="keyword">in</span> enumerate(T):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> temp &gt; stack[<span class="number">-1</span>][<span class="number">0</span>]:</span><br><span class="line">            pre_temp, j = stack.pop()</span><br><span class="line">            warmer[j] = i - j</span><br><span class="line">        stack.append((temp, i))</span><br><span class="line">    <span class="keyword">return</span> warmer</span><br></pre></td></tr></table></figure></p><h2 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71. Simplify Path"></a>71. Simplify Path</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">self, path: str</span>) -&gt; str:</span></span><br><span class="line">    stack = []</span><br><span class="line">    paths = path.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> paths:</span><br><span class="line">        <span class="keyword">if</span> p == <span class="string">&#x27;..&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> p == <span class="string">&#x27;.&#x27;</span> <span class="keyword">or</span> p == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(p)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;/&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Stack Problem Collection (1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;20.Valid Parentheses&lt;/li&gt;
&lt;li&gt;1249.Minimum Remove to Make Valid Parentheses&lt;/li&gt;
&lt;li&gt;394.Decode String&lt;/li&gt;
&lt;li&gt;1209.Remove All Adjacent Duplicates in String II&lt;/li&gt;
&lt;li&gt;739.Daily Temperatures&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Simplify Path&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://testsiling.github.io/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Dynamic Programming (1)</title>
    <link href="http://testsiling.github.io/2020/12/14/al-dp-1/"/>
    <id>http://testsiling.github.io/2020/12/14/al-dp-1/</id>
    <published>2020-12-15T01:30:55.000Z</published>
    <updated>2020-12-15T01:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Dynamic Programming Problem Collection (1)</p><p>Green hand in DP problem<br>The key of Dynamic Programming is to get local result, then get global result. </p><ul><li>70.Climbing Stairs</li><li>121.Best Time to Buy and Sell Stock *</li><li>53.Maximum Subarray</li><li>198.House Robber</li><li>746.Min Cost Climbing Stairs</li><li>42.Trapping Rain Water</li></ul><a id="more"></a><h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h2><script type="math/tex; mode=display">step_i = step_{i-1} + step_{i-2}</script><p>Tried to use recursion but it was super slow. Use iteration is much faster.</p><p>calculate the previous step 1 and step 2, keep tracking it. Time = O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">    p1, p2 = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">        cur = p1 + p2</span><br><span class="line">        p1, p2 = p2, cur</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h2><p>I like this one. logging the lowest buying price while updating max profit<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    lowest = prices[<span class="number">0</span>]</span><br><span class="line">    profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">        lowest = min(lowest, price)</span><br><span class="line">        profit = max(profit, price - lowest)</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure></p><h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h2><h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><p>find local max sum, update global max sum if greater.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">    max_sum = nums[<span class="number">0</span>]</span><br><span class="line">    cur_sum = nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        cur_sum = max(cur_sum + num, num)</span><br><span class="line">        max_sum = max(cur_sum, max_sum)</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure></p><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">    dp = [<span class="number">0</span>] * len(nums)</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums)</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>] + num, num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h2 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> max(nums, default=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    gain = [<span class="number">0</span>] * len(nums)</span><br><span class="line">    gain[<span class="number">0</span>], gain[<span class="number">1</span>] = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">        <span class="comment"># Two options:</span></span><br><span class="line">        <span class="comment"># 1) rob it, gain(i) = gain(i-2) + current money</span></span><br><span class="line">        <span class="comment"># 2) don&#x27;t rob it, current max gain is gain(i - 1)</span></span><br><span class="line">        gain[i] = max(gain[i - <span class="number">2</span>] + nums[i], gain[i - <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gain[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="746-Min-Cost-Climbing-Stairs"><a href="#746-Min-Cost-Climbing-Stairs" class="headerlink" title="746. Min Cost Climbing Stairs"></a>746. Min Cost Climbing Stairs</h2><p>Either pay the last step, or pay the second last step<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: List[int]</span>) -&gt; int:</span></span><br><span class="line">    s0, s1 = cost[<span class="number">0</span>], cost[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(cost)):</span><br><span class="line">        s1, s0 = min(cost[i] + s0, cost[i] + s1), s1</span><br><span class="line">    <span class="keyword">return</span> min(s0, s1)</span><br></pre></td></tr></table></figure></p><h2 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h2><p>DP solution, log left max, then log right max<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[int]</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(height) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    left_max, right_max = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># left, right, rain</span></span><br><span class="line">    dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(height))]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># find left max:</span></span><br><span class="line">    <span class="keyword">for</span> i, h <span class="keyword">in</span> enumerate(height):</span><br><span class="line">        dp[i][<span class="number">0</span>] = left_max</span><br><span class="line">        left_max = max(h, left_max)</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="comment"># find right max, calculate rain</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        dp[i][<span class="number">1</span>] = right_max</span><br><span class="line">        right_max = max(right_max, height[i])</span><br><span class="line">        res += max(min(dp[i][<span class="number">0</span>], dp[i][<span class="number">1</span>]) - height[i], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><br>It also has a stack solution.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Dynamic Programming Problem Collection (1)&lt;/p&gt;
&lt;p&gt;Green hand in DP problem&lt;br&gt;The key of Dynamic Programming is to get local result, then get global result. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;70.Climbing Stairs&lt;/li&gt;
&lt;li&gt;121.Best Time to Buy and Sell Stock *&lt;/li&gt;
&lt;li&gt;53.Maximum Subarray&lt;/li&gt;
&lt;li&gt;198.House Robber&lt;/li&gt;
&lt;li&gt;746.Min Cost Climbing Stairs&lt;/li&gt;
&lt;li&gt;42.Trapping Rain Water&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://testsiling.github.io/tags/Dynamic-Programming/"/>
    
    <category term="Greedy" scheme="http://testsiling.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Sorting (1)</title>
    <link href="http://testsiling.github.io/2020/12/10/al-sort-search-1/"/>
    <id>http://testsiling.github.io/2020/12/10/al-sort-search-1/</id>
    <published>2020-12-10T19:00:29.000Z</published>
    <updated>2020-12-10T19:00:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Sorting Problem Collection (1)</p><ul><li>56.Merge Intervals</li><li>253.Meeting Rooms II</li><li>973.K Closest Points to Origin</li><li>148.Sort List *</li><li>88.Merge Sorted Array</li></ul><a id="more"></a><h2 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a>56. Merge Intervals</h2><p>Sort first, then merge. Pretty straight forward.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: List[List[int]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">    intervals.sort()</span><br><span class="line">    begin, end = intervals[<span class="number">0</span>]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> cur_begin, cur_end <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> cur_begin &lt;= end:</span><br><span class="line">            end = max(end, cur_end)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append([begin, end])</span><br><span class="line">            begin, end = cur_begin, cur_end</span><br><span class="line">    res.append([begin, end])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253. Meeting Rooms II"></a>253. Meeting Rooms II</h2><p>I use hashmap to log current using rooms. <code>free</code> variable is for reducing times of <code>sum(rooms.values())</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMeetingRooms</span>(<span class="params">self, intervals: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    intervals.sort()</span><br><span class="line">    rooms = defaultdict(int)</span><br><span class="line">    cnt, free = <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> start, end <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">for</span> time <span class="keyword">in</span> list(rooms.keys()):</span><br><span class="line">            <span class="keyword">if</span> start &gt;= time[<span class="number">-1</span>]:</span><br><span class="line">                free += rooms[time]</span><br><span class="line">                <span class="keyword">del</span> rooms[time] </span><br><span class="line">        rooms[(start, end)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> free &gt; <span class="number">0</span>:</span><br><span class="line">            free -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure></p><h2 id="973-K-Closest-Points-to-Origin"><a href="#973-K-Closest-Points-to-Origin" class="headerlink" title="973. K Closest Points to Origin"></a>973. K Closest Points to Origin</h2><p>I feels like it is a hack… pretty straight forward though.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points: List[List[int]], K: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">    points.sort(key = <span class="keyword">lambda</span> p: p[<span class="number">0</span>]**<span class="number">2</span> + p[<span class="number">1</span>]**<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> points[:K]</span><br></pre></td></tr></table></figure></p><h2 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a>148. Sort List</h2><p>A nice one, bascially is a merge sort</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">      dummy = ListNode()</span><br><span class="line">      cur = dummy</span><br><span class="line">      <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">          cur.next = l1</span><br><span class="line">          l1 = l1.next</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">            cur.next = l2</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">            cur.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">            <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">          </span><br><span class="line">          <span class="comment"># use 2 pointers to divide into 2 lsits</span></span><br><span class="line">          <span class="comment"># slow is list 2</span></span><br><span class="line">          p, slow, fast = <span class="literal">None</span>, head, head</span><br><span class="line">          <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            p = slow</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            p.next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> merge(self.sortList(head), self.sortList(slow))</span><br></pre></td></tr></table></figure><h2 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a>88. Merge Sorted Array</h2><p>I don’t think it is an Easy at all.<br>My initial solution: maintain 2 pointers, current index of nums1, and nums2. If n1 &gt; n2, need ro insert n2 before n1. which means swap all the following digit from n1 till the end of num1.<br>This solution is pretty slow. Time complexity is O(m^n)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[int], m: int, nums2: List[int], n: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    i1, i2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i2 &lt; n <span class="keyword">and</span> i1 &lt; m:</span><br><span class="line">        <span class="keyword">if</span> nums1[i1 + i2] &gt; nums2[i2]:</span><br><span class="line">            pre = nums2[i2]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(i1 + i2, m + i2 + <span class="number">1</span>):</span><br><span class="line">                temp = nums1[i]</span><br><span class="line">                nums1[i] = pre</span><br><span class="line">                pre = temp</span><br><span class="line">            i2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i2 &lt; n:</span><br><span class="line">        nums1[i1 + i2: ] = nums2[i2:]</span><br></pre></td></tr></table></figure></p><p>Assign descending can avoid swapping.<br>time: O(n+m)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[int], m: int, nums2: List[int], n: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    i1 = m - <span class="number">1</span></span><br><span class="line">    i2 = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m + n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> i1 &lt; <span class="number">0</span>: </span><br><span class="line">            nums1[i] = nums2[i2]</span><br><span class="line">            i2 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> i2 &lt; <span class="number">0</span>:</span><br><span class="line">            nums1[i] = nums1[i1]</span><br><span class="line">            i1 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums2[i2] &gt; nums1[i1]:</span><br><span class="line">            nums1[i] = nums2[i2]</span><br><span class="line">            i2 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums1[i] = nums1[i1]</span><br><span class="line">            i1 -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Sorting Problem Collection (1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;56.Merge Intervals&lt;/li&gt;
&lt;li&gt;253.Meeting Rooms II&lt;/li&gt;
&lt;li&gt;973.K Closest Points to Origin&lt;/li&gt;
&lt;li&gt;148.Sort List *&lt;/li&gt;
&lt;li&gt;88.Merge Sorted Array&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Sorting" scheme="http://testsiling.github.io/tags/Sorting/"/>
    
    <category term="Searching" scheme="http://testsiling.github.io/tags/Searching/"/>
    
  </entry>
  
  <entry>
    <title>Classical Sorting Algorithms</title>
    <link href="http://testsiling.github.io/2020/12/09/al-sort-classical/"/>
    <id>http://testsiling.github.io/2020/12/09/al-sort-classical/</id>
    <published>2020-12-10T04:02:28.000Z</published>
    <updated>2020-12-10T04:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>Name</th><th>Time Complexity</th><th>Sapce Complexity</th></tr></thead><tbody><tr><td>Bubble Sort</td><td>O(n^2)</td><td>O(1)</td></tr><tr><td>Selection Sort</td><td>O(n^2)</td><td>O(1)</td></tr><tr><td>Insertion Sort</td><td>O(n^2)</td><td>O(1)</td></tr><tr><td>Merge Sort</td><td>O(n log(n))</td><td>O(n)</td></tr><tr><td>Quick Sort</td><td>O(n^2)</td><td>O(log(n))</td></tr><tr><td>Heap Sort</td><td>O(n log(n))</td><td>O(1)</td></tr><tr><td>Counting Sort</td><td>O(n+k)</td><td>O(k)</td></tr><tr><td>Radix Sort</td><td>O(nk)</td><td>O(n+k)</td></tr></tbody></table></div><a id="more"></a><h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">ls</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ls) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(ls) - <span class="number">1</span>  - i):</span><br><span class="line">            <span class="keyword">if</span> ls[j] &gt; ls[j + <span class="number">1</span>]:</span><br><span class="line">                ls[j], ls[j+<span class="number">1</span>] = ls[j+<span class="number">1</span>], ls[j]</span><br><span class="line">    <span class="keyword">return</span> ls</span><br></pre></td></tr></table></figure><h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectSort</span>(<span class="params">ls</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ls)):</span><br><span class="line">        mini = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(ls)):</span><br><span class="line">            <span class="keyword">if</span> ls[j] &lt; ls[mini]:</span><br><span class="line">                mini = j</span><br><span class="line">            ls[mini], ls[i] = ls[i], ls[mini]</span><br><span class="line">    <span class="keyword">return</span> ls</span><br></pre></td></tr></table></figure><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span>(<span class="params">ls</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(ls)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> ls[j] &gt;= ls[j - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            ls[j], ls[j - <span class="number">1</span>] = ls[j - <span class="number">1</span>], ls[j]</span><br><span class="line">    <span class="keyword">return</span> ls</span><br></pre></td></tr></table></figure><h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><p>An <code>divide and conquer</code> approch.</p><ol><li>If the list is of length 0 or 1, then it is already sorted. Otherwise:</li><li>Divide the unsorted list into two sublists of about half the size.</li><li>Sort each sublist recursively by re-applying merge sort.</li><li>Merge the two sublists back into one sorted list.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">arr1, arr2</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> arr1 <span class="keyword">and</span> arr2:</span><br><span class="line">        <span class="keyword">if</span> arr1[<span class="number">0</span>] &lt;= arr2[<span class="number">0</span>]:</span><br><span class="line">            res.append(arr1.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(arr2.pop(<span class="number">0</span>))</span><br><span class="line">        res += arr1 <span class="keyword">if</span> arr1 <span class="keyword">else</span> arr2</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    left = arr[:len(arr) // <span class="number">2</span>]</span><br><span class="line">    right = arr[len(arr) // <span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br></pre></td></tr></table></figure><h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><p>An divide and conquer strategy. Select a <code>pivot</code>. elements less than pivot, move to the left side, else move to the right side.<br><em>set the first element as pivot</em><br>Sort in place:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>):</span></span><br><span class="line">    pivot = arr[right]</span><br><span class="line">    i = left - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(left, right):</span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt;= pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">    arr[i + <span class="number">1</span>], arr[right] = arr[right], arr[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>):</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        q = partition(arr, left, right)</span><br><span class="line">        quickSort(arr, left, q - <span class="number">1</span>)</span><br><span class="line">        quickSort(arr, q + <span class="number">1</span>, right)</span><br></pre></td></tr></table></figure></p><h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><p><a href="https://github.com/python/cpython/blob/3.9/Lib/heapq.py">Heapq Module</a><br><a href="https://en.wikipedia.org/wiki/Heapsort">About Heap Sort</a></p><ol><li>Build a max heap</li><li>replace the root (current largest number) with the last item and reduce the heap size by 1. At this time, the largerst number is sorted and excluded from the heap. </li><li>repeat step 2</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">arr, n, i</span>):</span></span><br><span class="line">    largest = i  <span class="comment"># Initialize largest as root</span></span><br><span class="line">    l = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    r = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># check if any child is greater than root</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> arr[largest] &lt; arr[l]:</span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> arr[largest] &lt; arr[r]:</span><br><span class="line">        largest = r</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># if child greater than node, bubble it up.</span></span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]  <span class="comment"># swap</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Heapify the root.</span></span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    n = len(arr)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Build a maxheap.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(n // <span class="number">2</span>)):</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># get sorted items one by one</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">1</span>, n)):</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]  <span class="comment"># swap</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h2>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Time Complexity&lt;/th&gt;
&lt;th&gt;Sapce Complexity&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Bubble Sort&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Selection Sort&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Insertion Sort&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Merge Sort&lt;/td&gt;
&lt;td&gt;O(n log(n))&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Quick Sort&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;O(log(n))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Heap Sort&lt;/td&gt;
&lt;td&gt;O(n log(n))&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Counting Sort&lt;/td&gt;
&lt;td&gt;O(n+k)&lt;/td&gt;
&lt;td&gt;O(k)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Radix Sort&lt;/td&gt;
&lt;td&gt;O(nk)&lt;/td&gt;
&lt;td&gt;O(n+k)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Sorting" scheme="http://testsiling.github.io/tags/Sorting/"/>
    
    <category term="Heap" scheme="http://testsiling.github.io/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Tree (2)</title>
    <link href="http://testsiling.github.io/2020/12/06/al-tree-2/"/>
    <id>http://testsiling.github.io/2020/12/06/al-tree-2/</id>
    <published>2020-12-07T04:28:42.000Z</published>
    <updated>2020-12-07T04:28:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Tree problem collection (2)</p><ul><li>199.Binary Tree Right Side View</li><li>105.Construct Binary Tree from Preorder and Inorder Traversal</li><li>236.Lowest Common Ancestor of a Binary Tree</li><li>987.Vertical Order Traversal of a Binary Tree</li><li>103.Binary Tree Zigzag Level Order Traversal</li></ul><a id="more"></a><p>Basic About Tree:<br>Preorder: root - left - right<br>Inorder: left - root - right<br>Postorder: left - right - root</p><h2 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a>199. Binary Tree Right Side View</h2><p>dfs, root -&gt; right -&gt; left<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">    res = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, level = <span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> level <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            res[level] = node.val</span><br><span class="line">        dfs(node.right, level + <span class="number">1</span>)</span><br><span class="line">        dfs(node.left, level + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> list(res.values())</span><br></pre></td></tr></table></figure></p><h2 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h2><p>get root from 1st level of preorder<br>get child inorder by deviding inorder by root.val<br>get child preorder by number of child inorder</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[int], inorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    root = TreeNode(preorder.pop(<span class="number">0</span>))</span><br><span class="line">    i = inorder.index(root.val)</span><br><span class="line">    </span><br><span class="line">    left_inorder = inorder[:i]</span><br><span class="line">    left_preorder = preorder[:len(left_inorder)]</span><br><span class="line">    </span><br><span class="line">    right_inorder = inorder[i + <span class="number">1</span>:]</span><br><span class="line">    right_preorder = preorder[len(left_inorder): ]</span><br><span class="line">    </span><br><span class="line">    root.left = self.buildTree(left_preorder, left_inorder)</span><br><span class="line">    root.right = self.buildTree(right_preorder, right_inorder)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h2><p>My initial AC is backtracking but only beats 5%… I searched all ancestor of p and q and find their LCA, which is super low. Here’s a more concise DFS solution<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> right:</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure></p><h2 id="987-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#987-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="987. Vertical Order Traversal of a Binary Tree"></a>987. Vertical Order Traversal of a Binary Tree</h2><p>Use Hashmap to log node coordinate. If in the same y level, sort it.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    coordinates = defaultdict(<span class="keyword">lambda</span>: defaultdict(list))</span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInorder</span>(<span class="params">node, x, y</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        coordinates[x][y].append(node.val)</span><br><span class="line">        searchInorder(node.left, x<span class="number">-1</span>, y<span class="number">-1</span>)</span><br><span class="line">        searchInorder(node.right, x+<span class="number">1</span>, y<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    searchInorder(root, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> sorted(coordinates.keys()):</span><br><span class="line">        cur = []</span><br><span class="line">        levels = coordinates[x]</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> sorted(levels.keys(), reverse=<span class="literal">True</span>):</span><br><span class="line">            cur += sorted(levels[y])</span><br><span class="line">        res.append(cur)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a>103. Binary Tree Zigzag Level Order Traversal</h2><p>Classic BFS.<br>Odd level: left -&gt; right<br>Even level: right -&gt; left<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    q = [(root, <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        node, level = q.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> len(res) &lt; level:</span><br><span class="line">            res.append([])</span><br><span class="line">        <span class="comment"># odd level: left -&gt; right</span></span><br><span class="line">        <span class="keyword">if</span> bool(level % <span class="number">2</span>):</span><br><span class="line">            res[level - <span class="number">1</span>].append(node.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[level - <span class="number">1</span>] = [node.val] + res[level - <span class="number">1</span>] </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            q.append((node.left, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            q.append((node.right, level + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Tree problem collection (2)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;199.Binary Tree Right Side View&lt;/li&gt;
&lt;li&gt;105.Construct Binary Tree from Preorder and Inorder Traversal&lt;/li&gt;
&lt;li&gt;236.Lowest Common Ancestor of a Binary Tree&lt;/li&gt;
&lt;li&gt;987.Vertical Order Traversal of a Binary Tree&lt;/li&gt;
&lt;li&gt;103.Binary Tree Zigzag Level Order Traversal&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Tree" scheme="http://testsiling.github.io/tags/Tree/"/>
    
    <category term="BFS" scheme="http://testsiling.github.io/tags/BFS/"/>
    
    <category term="DFS" scheme="http://testsiling.github.io/tags/DFS/"/>
    
    <category term="Hash Table" scheme="http://testsiling.github.io/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Tree (1)</title>
    <link href="http://testsiling.github.io/2020/12/02/al-tree-1/"/>
    <id>http://testsiling.github.io/2020/12/02/al-tree-1/</id>
    <published>2020-12-03T01:15:03.000Z</published>
    <updated>2020-12-03T01:15:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Tree problem collection (1)</p><ul><li>104.Maximum Depth of Binary Tree</li><li>98.Validate Binary Search Tree</li><li>101.Symmetric Tree</li><li>102.Binary Tree Level Order Traversal</li><li>108.Convert Sorted Array to Binary Search Tree</li></ul><p>Inorder (Left, Root, Right)<br>Preorder (Root, Left, Right)<br>Postorder (Left, Right, Root)<br><a id="more"></a></p><h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h2><p>DFS:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root.left:</span><br><span class="line">        left = self.maxDepth(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right:</span><br><span class="line">        right = self.maxDepth(root.right)</span><br><span class="line">    <span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>BFS:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    q = [(root, <span class="number">1</span>)]</span><br><span class="line">    depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        cur, d = q.pop()</span><br><span class="line">        depth = max(d, depth)</span><br><span class="line">        <span class="keyword">if</span> cur.left:</span><br><span class="line">            q.append((cur.left, d + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> cur.right:</span><br><span class="line">            q.append((cur.right, d + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure></p><h2 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h2><p>This one is interesting<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode,  floor=float(<span class="params"><span class="string">&#x27;-inf&#x27;</span></span>), ceil = float(<span class="params"><span class="string">&#x27;inf&#x27;</span></span>)</span>) -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> floor &lt; root.val &lt; ceil:</span><br><span class="line">        <span class="keyword">return</span> self.isValidBST(root.left, floor, root.val) <span class="keyword">and</span> self.isValidBST(root.right, root.val, ceil)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><h2 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">    q = [root, root]</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        right = q.pop()</span><br><span class="line">        left = q.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># empty sub tree</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (left <span class="keyword">and</span> <span class="keyword">not</span> right) <span class="keyword">or</span> (<span class="keyword">not</span> left <span class="keyword">and</span> right) <span class="keyword">or</span> (left.val != right.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># mirror check</span></span><br><span class="line">        q += [left.left, right.right, left.right, right.left]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    q = [root]</span><br><span class="line">    cur_nodes = <span class="number">1</span></span><br><span class="line">    child_nodes = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    cur = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        node = q.pop(<span class="number">0</span>)</span><br><span class="line">        cur_nodes  -= <span class="number">1</span></span><br><span class="line">        cur.append(node.val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            q.append(node.left)</span><br><span class="line">            child_nodes += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            q.append(node.right)</span><br><span class="line">            child_nodes += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cur_nodes == <span class="number">0</span>:</span><br><span class="line">            res.append(cur)</span><br><span class="line">            cur = []</span><br><span class="line">            cur_nodes = child_nodes</span><br><span class="line">            child_nodes = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">    levels = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> levels</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, level</span>):</span></span><br><span class="line">        <span class="keyword">if</span> len(levels) == level:</span><br><span class="line">            levels.append([])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># append the current node value</span></span><br><span class="line">        levels[level].append(node.val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># process child nodes for the next level</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            dfs(node.left, level + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            dfs(node.right, level + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    dfs(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> levels</span><br></pre></td></tr></table></figure><h2 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a>108. Convert Sorted Array to Binary Search Tree</h2><p>Typical DFS<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    i = int(len(nums) / <span class="number">2</span>)</span><br><span class="line">    node = TreeNode(nums[i])</span><br><span class="line">    node.left = self.sortedArrayToBST(nums[: i])</span><br><span class="line">    node.right = self.sortedArrayToBST(nums[i + <span class="number">1</span>: ])</span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Tree problem collection (1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;104.Maximum Depth of Binary Tree&lt;/li&gt;
&lt;li&gt;98.Validate Binary Search Tree&lt;/li&gt;
&lt;li&gt;101.Symmetric Tree&lt;/li&gt;
&lt;li&gt;102.Binary Tree Level Order Traversal&lt;/li&gt;
&lt;li&gt;108.Convert Sorted Array to Binary Search Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Inorder (Left, Root, Right)&lt;br&gt;Preorder (Root, Left, Right)&lt;br&gt;Postorder (Left, Right, Root)&lt;br&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Data Structure" scheme="http://testsiling.github.io/tags/Data-Structure/"/>
    
    <category term="Tree" scheme="http://testsiling.github.io/tags/Tree/"/>
    
    <category term="BFS" scheme="http://testsiling.github.io/tags/BFS/"/>
    
    <category term="DFS" scheme="http://testsiling.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Linked List (1)</title>
    <link href="http://testsiling.github.io/2020/12/01/al-linked-list-1/"/>
    <id>http://testsiling.github.io/2020/12/01/al-linked-list-1/</id>
    <published>2020-12-01T17:16:25.000Z</published>
    <updated>2020-12-01T17:16:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode linked list problem collection (1)</p><ul><li>19.Remove Nth Node From End of List</li><li>206.Reverse Linked List</li><li>21.Merge Two Sorted Lists</li><li>234.Palindrome Linked List</li><li>141.Linked List Cycle</li><li>203.Remove Linked List Elements</li><li>83.Remove Duplicates from Sorted List</li><li>2.Add Two Numbers</li><li>876.Middle of the Linked List</li><li>369.Plus One Linked List</li></ul><a id="more"></a><h2 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h2><p>Two pointers solution: right pointer is <code>n</code> step behind left pointer. When right pointer reache the end of the linked list, <code>left.next</code> is the node that should be removed.<br>Hint: Dummy node usually very useful in linked list algorithms.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: int</span>) -&gt; ListNode:</span></span><br><span class="line">    dummy = ListNode(next=head)       </span><br><span class="line">    left = dummy</span><br><span class="line">    right = left</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        right = right.next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> right.next:</span><br><span class="line">        right = right.next</span><br><span class="line">        left = left.next</span><br><span class="line">    </span><br><span class="line">    left.next = left.next.next</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h2><h3 id="Iterative"><a href="#Iterative" class="headerlink" title="Iterative"></a>Iterative</h3><ul><li>None -&gt; 1 -&gt; 2</li><li>None &lt;- 1    2</li><li>None &lt;- 1 &lt;- 2</li></ul><p>The key is use a pointer to track <code>2</code> while adjusting <code>1.next</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nex = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nex</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></p><h3 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a>Recursive</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">pre: ListNode, cur:ListNode</span>) -&gt; ListNode:</span>    </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        nex = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        reverse(cur, nex)  </span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    tail = head</span><br><span class="line">    <span class="keyword">while</span> tail.next:</span><br><span class="line">        tail = tail.next</span><br><span class="line">    </span><br><span class="line">    reverse(<span class="literal">None</span>, head)</span><br><span class="line">    <span class="keyword">return</span> tail</span><br></pre></td></tr></table></figure><h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    cur = ListNode()</span><br><span class="line">    dummy = cur</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        cur.next = ListNode()</span><br><span class="line">        cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            cur.val = l1.val</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.val = l2.val</span><br><span class="line">            l2 = l2.next</span><br><span class="line">    </span><br><span class="line">    cur.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a>234. Palindrome Linked List</h2><p>O(n) time<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">    vals = []</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">        vals.append(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    a = vals[:l // <span class="number">2</span>]</span><br><span class="line">    b = vals[l // <span class="number">2</span> + l % <span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> a == b[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h2 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h2><p>Technically is a hash table. tag visited.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">    cur = ListNode(next=head)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># set cur val to None if visited</span></span><br><span class="line">    <span class="keyword">while</span> cur.next:</span><br><span class="line">        cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        cur.val = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><p>Two pointers solution<br>This solution is more like an intelligence test. 🙃</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    slow = head</span><br><span class="line">    fast = head.next</span><br><span class="line">    <span class="keyword">while</span> (slow != fast):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.next:</span><br><span class="line">            <span class="comment"># reach an end</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203. Remove Linked List Elements"></a>203. Remove Linked List Elements</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head: ListNode, val: int</span>) -&gt; ListNode:</span></span><br><span class="line">    dummy = ListNode(next=head)</span><br><span class="line">    pre = dummy</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> cur.val == val:</span><br><span class="line">            pre.next = cur.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = pre.next</span><br><span class="line">        cur = pre.next</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83. Remove Duplicates from Sorted List"></a>83. Remove Duplicates from Sorted List</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    dummy = ListNode(next=head)</span><br><span class="line">    pre, cur = dummy, head</span><br><span class="line">    val = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> val == <span class="literal">None</span> <span class="keyword">or</span> cur.val != val:</span><br><span class="line">            val = cur.val</span><br><span class="line">            pre = cur</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre.next = cur.next</span><br><span class="line">        cur = cur.next</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    dummy = ListNode()</span><br><span class="line">    cur = dummy</span><br><span class="line">    carry = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            l1 = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">            l2 = ListNode(<span class="number">0</span>)</span><br><span class="line">        val = l1.val + l2.val + carry</span><br><span class="line">        carry = val // <span class="number">10</span>            </span><br><span class="line">        cur.next = ListNode(val % <span class="number">10</span>)</span><br><span class="line">        cur = cur.next</span><br><span class="line">        l1 = l1.next</span><br><span class="line">        l2 = l2.next</span><br><span class="line">    <span class="keyword">if</span> carry:</span><br><span class="line">        cur.next = ListNode(carry)</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id="876-Middle-of-the-Linked-List"><a href="#876-Middle-of-the-Linked-List" class="headerlink" title="876. Middle of the Linked List"></a>876. Middle of the Linked List</h2><p>O(n) time<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">middleNode</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    mid = head</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">        cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l % <span class="number">2</span>:</span><br><span class="line">            mid = mid.next</span><br><span class="line">    <span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure></p><h2 id="369-Plus-One-Linked-List"><a href="#369-Plus-One-Linked-List" class="headerlink" title="369. Plus One Linked List"></a>369. Plus One Linked List</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.next:</span><br><span class="line">            val = node.val + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            val = node.val + helper(node.next)</span><br><span class="line">        node.val = val % <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> val // <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ListNode(<span class="number">1</span>, head) <span class="keyword">if</span> helper(head) <span class="keyword">else</span> head</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode linked list problem collection (1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;19.Remove Nth Node From End of List&lt;/li&gt;
&lt;li&gt;206.Reverse Linked List&lt;/li&gt;
&lt;li&gt;21.Merge Two Sorted Lists&lt;/li&gt;
&lt;li&gt;234.Palindrome Linked List&lt;/li&gt;
&lt;li&gt;141.Linked List Cycle&lt;/li&gt;
&lt;li&gt;203.Remove Linked List Elements&lt;/li&gt;
&lt;li&gt;83.Remove Duplicates from Sorted List&lt;/li&gt;
&lt;li&gt;2.Add Two Numbers&lt;/li&gt;
&lt;li&gt;876.Middle of the Linked List&lt;/li&gt;
&lt;li&gt;369.Plus One Linked List&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Linked List" scheme="http://testsiling.github.io/tags/Linked-List/"/>
    
    <category term="Two Pointers" scheme="http://testsiling.github.io/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Docker Container</title>
    <link href="http://testsiling.github.io/2020/10/22/docker-1/"/>
    <id>http://testsiling.github.io/2020/10/22/docker-1/</id>
    <published>2020-10-22T18:07:36.000Z</published>
    <updated>2020-10-22T18:07:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>I heard the words, <em>container</em>, and <em>docker</em> a lot. I know they refer to a tool related to Dev/Ops, but I never use one before. Recently I am writing a tool to find the best apartment (rent goes down since COVID19). Then I I think probably I should use docker in the apt finder project. This article is the first glimpse of docker. I would say it’s magical. </p><a id="more"></a><h2 id="What’s-Docker"><a href="#What’s-Docker" class="headerlink" title="What’s Docker?"></a>What’s Docker?</h2><p>Container is a solution of isolating &amp; running different applications on the same infrasturcture.<br><a href="https://www.docker.com/resources/what-container">https://www.docker.com/resources/what-container</a></p><p>Docker is a type of containers.</p><h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><p>Full tutorial: <a href="https://www.docker.com/101-tutorial">https://www.docker.com/101-tutorial</a></p><h3 id="Getting-Start-Container"><a href="#Getting-Start-Container" class="headerlink" title="Getting Start Container"></a>Getting Start Container</h3><ol><li><p>Create Dockerfile</p><p>A Dockerfile is simply a text-based script of instructions that is used to create a container image.</p></li><li><p>Run it!</p><p>Running the new container in “detached” mode (in the background) and creating a mapping between the host’s port 3000 to the container’s port 3000. </p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;app name&gt; .</span><br><span class="line">docker run -dp <span class="number">3000</span>:<span class="number">3000</span> &lt;app name&gt;</span><br></pre></td></tr></table></figure><h3 id="Updating-App"><a href="#Updating-App" class="headerlink" title="Updating App"></a>Updating App</h3><ol><li><p>Change source code. </p></li><li><p>Build new image. </p></li><li><p>Find the old container’s id, stop it, remove it. </p></li><li><p>Run the new image.</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;app name&gt; .</span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line">docker stop &lt;the-container-id&gt;</span><br><span class="line">docker rm &lt;the-container-id&gt;</span><br><span class="line"></span><br><span class="line">docker run -dp 3000:3000 docker-101</span><br></pre></td></tr></table></figure><h3 id="Sharing-App"><a href="#Sharing-App" class="headerlink" title="Sharing App"></a>Sharing App</h3><ol><li><p>Create repo on <a href="https://hub.docker.com/">https://hub.docker.com/</a> </p><p>for example, <em>101-todo-app</em></p></li><li><p>Login from local</p></li><li><p>Give image a new name</p></li><li><p>Push it.</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag docker-101 YOUR-USER-NAME/101-todo-app</span><br><span class="line">docker push YOUR-USER-NAME/101-todo-app</span><br></pre></td></tr></table></figure><ol><li>Running image on new instance</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 YOUR-USER-NAME/101-todo-app</span><br></pre></td></tr></table></figure><h3 id="Persisting-DB"><a href="#Persisting-DB" class="headerlink" title="Persisting DB"></a>Persisting DB</h3><p>to-do app as example. Docker will save data file on the host machine and make it available to the next container. Docker maintains the physical location on the disk and you only need to remember the name of the volume. </p><ol><li>create volume</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create todo-db</span><br></pre></td></tr></table></figure><ol><li><p>stop the previous todo app container</p></li><li><p>Start a new todo app container with [<strong>-v</strong>]</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 -v todo-db:/etc/todos YOUR-USER-NAME/101-todo-app</span><br></pre></td></tr></table></figure><ol><li>add items into todo list. then stop and remove the container.</li><li><p>start a new container with the same <strong>run</strong> command above</p></li><li><p>use <code>docker volume inspect todo-db</code> to check The <code>Mountpoint</code> is the actual location on the disk where the data is stored.</p></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><p><a href="https://www.docker.com/101-tutorial">https://www.docker.com/101-tutorial</a></p></li><li><p><a href="https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504">https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504</a></p></li><li><a href="https://www.docker.com/resources/what-container">https://www.docker.com/resources/what-container</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;I heard the words, &lt;em&gt;container&lt;/em&gt;, and &lt;em&gt;docker&lt;/em&gt; a lot. I know they refer to a tool related to Dev/Ops, but I never use one before. Recently I am writing a tool to find the best apartment (rent goes down since COVID19). Then I I think probably I should use docker in the apt finder project. This article is the first glimpse of docker. I would say it’s magical. &lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="http://testsiling.github.io/tags/docker/"/>
    
    <category term="container" scheme="http://testsiling.github.io/tags/container/"/>
    
    <category term="devops" scheme="http://testsiling.github.io/tags/devops/"/>
    
  </entry>
  
</feed>
