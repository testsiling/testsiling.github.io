<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BUG DEVELOPER</title>
  
  <subtitle>Debugging the world</subtitle>
  <link href="http://testsiling.github.io/atom.xml" rel="self"/>
  
  <link href="http://testsiling.github.io/"/>
  <updated>2022-10-02T13:39:34.000Z</updated>
  <id>http://testsiling.github.io/</id>
  
  <author>
    <name>Siling Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Clean Code Note - Principles, Patterns, and Practices</title>
    <link href="http://testsiling.github.io/2022/10/02/note-clean-code/"/>
    <id>http://testsiling.github.io/2022/10/02/note-clean-code/</id>
    <published>2022-10-02T13:39:34.000Z</published>
    <updated>2022-10-02T13:39:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>A note of <em>Clean Code</em>, part 1.<br><span id="more"></span></p><p>I have been heard of this book for years as the CORE of programming, but haven’t got a chance / time to read it until recent (yes, my life is full of excuses XD). I started to read while I was on a long flight, although the author of this book clearly stated, “This is not a “feel good” book that you can read on an airplane and finish before you land”. That is true, I read 1/4 of it on my trip from FL to CA, and decided to stop reading since it is a waste to read this practical and insignful yet, unlike many tedious software engineering books (I am not gonna name any of my textbooks), you can feel it sarcasticly entertaining when you found those bad coding practices and jokes are actually happening everywhere in your codebase.</p><h1 id="Principles-Patterns-and-Practices"><a href="#Principles-Patterns-and-Practices" class="headerlink" title="Principles, Patterns, and Practices"></a>Principles, Patterns, and Practices</h1><h2 id="Meaningful-Names"><a href="#Meaningful-Names" class="headerlink" title="Meaningful Names"></a>Meaningful Names</h2><h3 id="Use-Intention-Revealing-Names"><a href="#Use-Intention-Revealing-Names" class="headerlink" title="Use Intention-Revealing Names"></a>Use Intention-Revealing Names</h3><h3 id="Avoid-Disinformation"><a href="#Avoid-Disinformation" class="headerlink" title="Avoid Disinformation"></a>Avoid Disinformation</h3><ul><li>A truly awful example of disinformative names would be the use of lower-case <em>L</em> or uppercase <em>O</em> as variable names, especially in combination.<ul><li>Welp, I did use <em>l</em> stand for <em>list</em> in many of my scripts</li></ul></li><li>Try not to encode the container type into the name.</li></ul><h3 id="Make-Meaningful-Distinctions"><a href="#Make-Meaningful-Distinctions" class="headerlink" title="Make Meaningful Distinctions"></a>Make Meaningful Distinctions</h3><ul><li>Number-series naming (a1, a2, .. aN) is the opposite of intentional naming.</li><li>Noise words, such as <em>a</em>, <em>an</em>, <em>the</em>, <em>data</em>, <em>info</em>, are another meaningless distinction. They are redundant.</li></ul><h3 id="Use-Pronounceable-Names"><a href="#Use-Pronounceable-Names" class="headerlink" title="Use Pronounceable Names"></a>Use Pronounceable Names</h3><ul><li>Don’t over use acronym</li></ul><h3 id="Use-Searchable-Names"><a href="#Use-Searchable-Names" class="headerlink" title="Use Searchable Names"></a>Use Searchable Names</h3><ul><li>Single-letter names and numeric constants have a particular problem in that they are not easy to locate across a body of text.</li><li>Single-letter names can ONLY be used as local vari- ables inside short methods. </li><li>The length of a name should correspond to the size of its scope</li></ul><h3 id="Avoid-Encodings"><a href="#Avoid-Encodings" class="headerlink" title="Avoid Encodings"></a>Avoid Encodings</h3><h3 id="Avoid-Mental-Mapping"><a href="#Avoid-Mental-Mapping" class="headerlink" title="Avoid Mental Mapping"></a>Avoid Mental Mapping</h3><ul><li>This problem generally arises from a choice to use neither problem domain terms nor solution domain terms.</li><li>clarity is king</li></ul><h3 id="Class-Names"><a href="#Class-Names" class="headerlink" title="Class Names"></a>Class Names</h3><ul><li>Classes and objects should have noun or noun phrase names.</li><li>Avoid words like Manager, Processor, Data, or Info in the name of a class.<ul><li>In fact, we wrote a ton of <em>Manager</em> and <em>Processor</em> :(</li></ul></li></ul><h3 id="Method-Names"><a href="#Method-Names" class="headerlink" title="Method Names"></a>Method Names</h3><ul><li>Methods should have verb or verb phrase names.</li><li>Accessors, mutators, and predicates should be named for their value and prefixed with get, set, and is according to the javabean standard.</li></ul><h3 id="Don’t-Be-Cute"><a href="#Don’t-Be-Cute" class="headerlink" title="Don’t Be Cute"></a>Don’t Be Cute</h3><ul><li>Say what you mean. Mean what you say.<ul><li>Well, I do like jokes. And our codebase includes <em>some</em> jokes (not from me)</li></ul></li></ul><h3 id="Pick-One-Word-per-Concept"><a href="#Pick-One-Word-per-Concept" class="headerlink" title="Pick One Word per Concept"></a>Pick One Word per Concept</h3><ul><li>Pick one word for one abstract concept and stick with it<ul><li>For instance, it’s confusing to have fetch, retrieve, and get as equivalent methods of different classes. </li><li>My personal experience is that it would be a little bit hard to coordinate if your teammates don’t know this practice. You can try to let them know during code review.</li></ul></li></ul><h3 id="Don’t-Pun"><a href="#Don’t-Pun" class="headerlink" title="Don’t Pun"></a>Don’t Pun</h3><ul><li>Avoid using the same word for two purposes. Using the same term for two different ideas is essentially a pun.</li></ul><h3 id="Use-Solution-Domain-Names"><a href="#Use-Solution-Domain-Names" class="headerlink" title="Use Solution Domain Names"></a>Use Solution Domain Names</h3><ul><li>Use computer science (CS) terms, algorithm names, pattern names, math terms, and so forth.</li></ul><h3 id="Use-Problem-Domain-Names"><a href="#Use-Problem-Domain-Names" class="headerlink" title="Use Problem Domain Names"></a>Use Problem Domain Names</h3><h3 id="Add-Meaningful-Context"><a href="#Add-Meaningful-Context" class="headerlink" title="Add Meaningful Context"></a>Add Meaningful Context</h3><ul><li>You need to place names in context for your reader by enclosing them in well-named classes, functions, or namespaces.</li><li>ex: <em>addrState</em> instead of <em>state</em> alone.</li></ul><h3 id="Don’t-Add-Gratuitous-Context"><a href="#Don’t-Add-Gratuitous-Context" class="headerlink" title="Don’t Add Gratuitous Context"></a>Don’t Add Gratuitous Context</h3><ul><li>Shorter names are generally better than longer ones, so long as they are clear. Add no more context to a name than is necessary.</li></ul><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="Small"><a href="#Small" class="headerlink" title="Small!"></a>Small!</h3><ul><li>Lines should not be 150 characters long. </li><li>Functions should not be 100 lines long. Functions should hardly ever be 20 lines long.</li><li>The indent level of a function (<em>if</em>, <em>else</em>, <em>while</em>) should not be greater than one or two.</li></ul><h3 id="Do-One-Thing"><a href="#Do-One-Thing" class="headerlink" title="Do One Thing"></a>Do One Thing</h3><ul><li>FUNCTIONS SHOULD DO ONE THING. THEY SHOULD DO IT WELL. THEY SHOULD DO IT ONLY.</li><li>If a function does only those steps that are one level below the stated name of the function, then the function is doing one thing. </li><li>Another way to know that a function is doing more than “one thing” is if you can extract another function from it with a name that is not merely a restatement of its implementation.</li></ul><h3 id="One-Level-of-Abstraction-per-Function"><a href="#One-Level-of-Abstraction-per-Function" class="headerlink" title="One Level of Abstraction per Function"></a>One Level of Abstraction per Function</h3><ul><li>We want the code to read like a top-down narrative.</li><li>Making the code read like a top-down set of TO paragraphs is an effective technique for keeping the abstraction level consistent.</li></ul><h3 id="Switch-Statements"><a href="#Switch-Statements" class="headerlink" title="Switch Statements"></a>Switch Statements</h3><ul><li>Try to avoid it. Switch statement usually is a symptom of your code is NOT doing <em>*one thing</em>.</li><li>We can make sure that each switch statement is buried in a low-level class and is never repeated.</li><li>They can be tolerated if they appear only once, are used to create polymorphic objects, and are hidden behind an inheritance relationship so that the rest of the system can’t see them.</li></ul><h3 id="Use-Descriptive-Names"><a href="#Use-Descriptive-Names" class="headerlink" title="Use Descriptive Names"></a>Use Descriptive Names</h3><h3 id="Function-Arguments"><a href="#Function-Arguments" class="headerlink" title="Function Arguments"></a>Function Arguments</h3><ul><li>The ideal number of arguments for a function is zero (niladic). Next comes one (monadic), followed closely by two (dyadic). Three arguments (triadic) should be avoided where possible. More than three (polyadic) requires very special justification—and then shouldn’t be used anyway.</li><li><p>Common Monadic Forms</p><ol><li>Asking a question about that argument. Ex: <em>boolean fileExists(”MyFile“)</em></li><li>Operating on that argument, transforming it into something else and returning it</li><li>In an event. In this form there is an input argument but no output argument.</li></ol></li><li><p>Flag Arguments</p><ul><li>Passing a boolean into a function is a truly terrible practice.</li></ul></li><li><p>Dyadic Functions</p><ul><li>Dyads come at a cost and should take advantage of what mechanims may be available to you to convert them into monads. </li></ul></li><li>Output Arguments<ul><li>In general output arguments should be avoided. If your function must change the state of something, have it change the state of its owning object.</li><li>(I found this one is kinda hard to follow as well, need practice.)</li></ul></li><li>Command Query Separation<ul><li>Functions should either do something or answer something, but not both.</li></ul></li><li>Prefer Exceptions to Returning Error Codes<ul><li>Error Handling Is One Thing</li><li>When you use exceptions rather than error codes, then new exceptions are derivatives of the exception class. They can be added without forcing any recompilation or redeployment.1</li></ul></li><li>Don’t Repeat Yourself</li><li>Structured Programming</li></ul><h3 id="How-Do-You-Write-Functions-Like-This"><a href="#How-Do-You-Write-Functions-Like-This" class="headerlink" title="How Do You Write Functions Like This?"></a>How Do You Write Functions Like This?</h3><p>You get your thoughts down first, then you massage it until it reads well.<br>Master programmers think of systems as stories to be told rather than programs to be written. </p><h2 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h2><h3 id="Good-Comments"><a href="#Good-Comments" class="headerlink" title="Good Comments"></a>Good Comments</h3><ul><li>Legal Comments</li><li>Informative Comments</li><li>Explanation of Intent</li><li>Clarification</li><li>Warning of Consequences</li><li>TODO Comments</li><li>Javadocs in Public APIs</li></ul><h3 id="Bad-Comments"><a href="#Bad-Comments" class="headerlink" title="Bad Comments"></a>Bad Comments</h3><ul><li>Mumbling</li><li>Redundant Comments</li><li>Misleading Comments</li><li>Mandated Comments</li><li>Journal Comments</li><li>Noise Comments</li><li>Scary Noise</li><li>Don’t Use a Comment When You Can Use a Function or a Variable</li><li>Position Markers</li><li>Closing Brace Comments</li><li>Attributions and Bylines</li><li>Commented-Out Code</li><li>HTML Comments</li><li>Nonlocal Information<ul><li>Ex: state “default value is xxx…” in a local comment</li></ul></li><li>Too Much Information<ul><li>Don’t put interesting historical discussions or irrelevant descriptions of details into your comments.</li></ul></li><li>Inobvious Connection</li><li>Function Headers</li><li>Javadocs in Nonpublic Code</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;A note of &lt;em&gt;Clean Code&lt;/em&gt;, part 1.&lt;br&gt;</summary>
    
    
    
    
    <category term="Software Engineering" scheme="http://testsiling.github.io/tags/Software-Engineering/"/>
    
    <category term="Programming" scheme="http://testsiling.github.io/tags/Programming/"/>
    
    <category term="Clean Code" scheme="http://testsiling.github.io/tags/Clean-Code/"/>
    
  </entry>
  
  <entry>
    <title>关于软件工程，设计，及Trade Off</title>
    <link href="http://testsiling.github.io/2022/03/24/software-engineering-1/"/>
    <id>http://testsiling.github.io/2022/03/24/software-engineering-1/</id>
    <published>2022-03-25T02:20:00.000Z</published>
    <updated>2022-03-25T02:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：文中提到的所有数据/日期/时间线均为虚构。</p><p>最近在做一个项目。鉴于我毕业之后在comcast写了一年多奇奇怪怪的计算模型，我感觉这是我步入职场后第一次真正的设计和领导一个项目（虽然目前，及可预见的未来也只有我一个人做）。一些关于开发的碎碎念吧。</p><span id="more"></span><h2 id="软件工程的教科书与现实"><a href="#软件工程的教科书与现实" class="headerlink" title="软件工程的教科书与现实"></a>软件工程的教科书与现实</h2><p>我们是有产品经理(Product Manager)的。但现实中的产品经理跟我书上学的完全不一样！</p><p>首先产品经理负责提出需求。当年学项目管理/需求管理的时候，第一步需要提出SMART(Specific, Measurable, Achievable, Relevant, Time bound) goal.</p><p>现实是，根本没有SMART goal!</p><p>跟PM沟通，给的需求非常抽象，没有范围，一切都可以由工程师自行裁定。</p><p>没有说这样的自由度不好的意思，就是弹性很大。PM都“既要又要”。你问他们要A还是B，他告诉你不冲突的话都要都要。所有目标/性能，问就是要最大最好的。就像手机流量明明只能用1T，非要买10T包。当然最后还是由工程师自由裁量。</p><p>不知道这种自由度是不是与我做的是infra项目有关。engineer driven。</p><h2 id="全都是trade-off！"><a href="#全都是trade-off！" class="headerlink" title="全都是trade off！"></a>全都是trade off！</h2><p>搞清楚需求以后<del>（发现无论我做啥他们都能接受）</del> ，开始设计。</p><p>基本上两个大方向：</p><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><ul><li>优点：用户使用简单，优雅，拓展性好（有后续项目需要在此项目基础上进行）</li><li>缺点：复杂，容错率低，耗时长（需要3-4个季度才能交付）</li></ul><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><ul><li>优点：简单，容错率高，实现快（只需要1个季度即可交付）</li><li>缺点：后续项目，及下游用户需要付出更多努力去适配，使用相对复杂。</li></ul><p>我现在也很迷惑：没有硬deadline和硬需求，PM聊过两个都可以接受，全都是自由裁量。</p><p>我自己喜欢方案1，因为从程序的角度来说优雅，下游及后续使用丝滑流畅。但是容错率低，如果发生错误的话会损失巨大。实现起来很复杂，intellectual control有难度。担心是否over engineering了？</p><p>我也喜欢方案2，短平快。因为代码简单，容错率高，也容易维护，容易实现intellectual control。</p><p>没有折中方案，两种方案的实现上除了框架，几乎没有可以复用的地方。</p><p>接下来估计跟各方聊天，写文档，然后敲定最终方案，另一个作为备用（不过如果你确定了设计之后，再发现问题启用备用的话，情况已经相当糟糕了）。</p><h3 id="如何考量一个功能是否作为独立的服务-micro-service"><a href="#如何考量一个功能是否作为独立的服务-micro-service" class="headerlink" title="如何考量一个功能是否作为独立的服务(micro service)"></a>如何考量一个功能是否作为独立的服务(micro service)</h3><p>你现在需要实现一个功能，如何考虑这个功能应该作为一个大服务中的功能，还是分出来作为单独的服务？基本的思路是：</p><ol><li>是不是一个工具类的功能，被多个服务使用? 是 -&gt; 独立服务；否 -&gt; 2</li><li>Is it worth to scaling the new function along with a larger service? （这句中文真的很讲）是 -&gt; 大服务中的小功能；否 -&gt; 独立服务</li></ol><p>我一开始被问到这个问题的时候，就想这个功能的复杂度/代码量啥的，然后被(友善地)教育了：不论代码量多少，都能作为独立服务。关键是要看【要不要一起scale】。例如大服务本来处理10TB数据，后来数据量暴增变成1000T了，要scale up。你这个小功能需要一起scale up吗？</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>就最近上班还学到蛮多的。自己管自己跟自己干活还蛮开心 :)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前言：文中提到的所有数据/日期/时间线均为虚构。&lt;/p&gt;
&lt;p&gt;最近在做一个项目。鉴于我毕业之后在comcast写了一年多奇奇怪怪的计算模型，我感觉这是我步入职场后第一次真正的设计和领导一个项目（虽然目前，及可预见的未来也只有我一个人做）。一些关于开发的碎碎念吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Software Engineering" scheme="http://testsiling.github.io/tags/Software-Engineering/"/>
    
  </entry>
  
  <entry>
    <title>最近</title>
    <link href="http://testsiling.github.io/2021/08/22/update0822/"/>
    <id>http://testsiling.github.io/2021/08/22/update0822/</id>
    <published>2021-08-22T10:12:57.000Z</published>
    <updated>2021-08-22T10:12:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更新啦，大家还好吗？也不知道这个blog有没有人在看。我最后一次更新是02/21/21，之后我换了一个工作。新公司在湾区，不过目前是remote from Philly。计划明年Q1会搬到湾区，如果疫情好转的话。</p><p>我是4月离开老东家，然后跟Lawrence度了一个长假，5月中入职新公司。8月刚过了我的社畜两周年纪念日。</p><span id="more"></span><h2 id="关于新工作"><a href="#关于新工作" class="headerlink" title="关于新工作"></a>关于新工作</h2><p>新工作跟以前完全不一样！现在是backend engineer，写API，micro service。刚进去啥都不会，连java都不会，不过边看边写感觉还蛮容易pickup的。关键是新公司的codebase很清晰！ramp up的时候感觉简直像“乡下人进城”一样，全都“哇好厉害”， “哇原来是这样”！用的工具全都没见过，在老东家手动完成的东西，新公司都有健全的工具链，然后各种guideline也很清晰，文档我觉得很健全（反正老东家是完全没有）。同事们都很友善，问什么问题都会得到回应，就整个反馈都很正向，work life balance我觉得客观来讲是很好的，业务熟悉之后很快就完成。很舒适！</p><p>刚开始的时候好多东西不会，学了一些grpc，java，restful，还有一些乱七八糟的东西（有时间会总结出来）。最大的感受就是“有些东西就是你见过就会知道，没见过就是不知道”。很多东西不是多高深，就是没听说过。前三个月读很多文档，我们组管很多个service，每一个都有设计文档，一些自己以前“希望做到但不知道best practice”的东西，这里都有。就收获很多吧。读文档跟挖矿一样，学到很多。</p><p>最近在做一个数据库的项目，一开始是先看了项目的设计文档，然后就觉得哇好厉害啊，每一步给出很多potential solution，分析优缺，跟其他组讨论推进，最后得到这个文档的我，看着就知道我应该要做什么，很清晰。跟别的同事闲聊的时候我就赞这个项目很清晰，同事说lead这个项目的engineer其实跟我差不多经验，相信我很快也可以做到。然后就感叹觉得自己其实并没有从上一份工作中得到很多软件工程上的指引，毕竟是一个非科技公司的偏硬件的组。也感谢自己去新公司的决定。希望不久的将来能成长成独当一面的工程师吧。</p><h2 id="关于找工作"><a href="#关于找工作" class="headerlink" title="关于找工作"></a>关于找工作</h2><p>其实一开始是Sherry老师要跳槽，喊我一起刷题。于是我们俩从12月开始正式刷题，还开了一个刷题打卡群，每天至少刷一题。我们一般新题一天5题，复习的时候高频题一天5-10题也有。最后一共刷了240题(101 easy, 111 medium, 28 hard)。wepay是我收到的第一个offer，觉得聊得挺好，包裹也满意，就接了，后面其他的就推了不想面了。Sherry老师很快拿到了相当好的offer，比我先走一步去西雅图。刷题打卡还蛮有用的！</p><p>感觉是觉得招工市场真的很好，开始海投之后就拿到了一些不错的面试，都懒得找内推了，跟newgrad的时候简历石沉大海真的差别很大。</p><h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><p>在我找工的时候就跟Lawrence达成一致：我去哪他去哪。所以当我确定湾区之后，他也开始学习啦。虽然他也是软件工程师，但不知道刷题为何物。给了他Sherry老师留下的cracking the technical interview，对他来说比直接上leetcode硬刷有用。其实我觉得问题不大，毕竟有工作经验。又不是每个公司都考很难的algorithm。我会支持他的！</p><p>最近半年就很顺利，感情甜蜜，工作轻松。5月刚度假完，又定了11月跟朋友们再去一次夏威夷。</p><p>唯一问题可能是之前欠太多信用卡，今年又想max out 401k，现在基本就是月欠族，paycheck还没到手已经被信用卡债/房租预定了，算了一下2022年之前我的财务状况大概不会有任何改善。</p><p>“那没钱怎么去度假呢？” —- 刷信用卡呀。看出来了吧这就是我没钱剩的原因。</p><p>真的好穷。加州税太贵了。我现在交加州税+Philly城市税。没房贷没孩子未婚，税务就一言难尽吧。</p><h2 id="Bottom-Line"><a href="#Bottom-Line" class="headerlink" title="Bottom Line"></a>Bottom Line</h2><p>工作顺利，感情甜蜜。</p><p>希望明年升职加薪。</p><p>希望疫情尽快结束。希望中美关系缓和，签证/运输早日无障碍互通，好久没回国了。</p><p>祝各位万事顺遂！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好久没更新啦，大家还好吗？也不知道这个blog有没有人在看。我最后一次更新是02/21/21，之后我换了一个工作。新公司在湾区，不过目前是remote from Philly。计划明年Q1会搬到湾区，如果疫情好转的话。&lt;/p&gt;
&lt;p&gt;我是4月离开老东家，然后跟Lawrence度了一个长假，5月中入职新公司。8月刚过了我的社畜两周年纪念日。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://testsiling.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="Daily" scheme="http://testsiling.github.io/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - KMP - Overview</title>
    <link href="http://testsiling.github.io/2021/02/21/al-kmp-0/"/>
    <id>http://testsiling.github.io/2021/02/21/al-kmp-0/</id>
    <published>2021-02-22T03:30:46.000Z</published>
    <updated>2021-02-22T03:30:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Knuth–Morris–Pratt algorithm, efficient single pattern searching algorithm.<br><span id="more"></span></p><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">p</span>):</span></span><br><span class="line">    kmp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p)):</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> p[i] != p[j]:</span><br><span class="line">            j = kmp[j]</span><br><span class="line">        <span class="keyword">if</span> p[i] == p[j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        kmp.append(j)</span><br><span class="line">    <span class="keyword">return</span> kmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span>(<span class="params">s, p</span>):</span></span><br><span class="line">    kmp = build(p)</span><br><span class="line">    ans = []</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> s[i] != p[j]:</span><br><span class="line">            j = kmp[j]</span><br><span class="line">        <span class="keyword">if</span> s[i] == p[j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j == <span class="built_in">len</span>(p):</span><br><span class="line">            ans.append(i - <span class="built_in">len</span>(p) + <span class="number">1</span>)</span><br><span class="line">            j = kmp[j]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><h3 id="1392-Longest-Happy-Prefix"><a href="#1392-Longest-Happy-Prefix" class="headerlink" title="1392. Longest Happy Prefix"></a>1392. Longest Happy Prefix</h3><p>using the KMP table.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPrefix</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    nxt = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> s[i] != s[j]:</span><br><span class="line">            j = nxt[j]</span><br><span class="line">        <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        nxt.append(j)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s[:nxt[-<span class="number">1</span>]]</span><br></pre></td></tr></table></figure></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zxi.mytechroad.com/blog/sp/kmp-algorithm-sp19/">huahua</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Knuth–Morris–Pratt algorithm, efficient single pattern searching algorithm.&lt;br&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="KMP" scheme="http://testsiling.github.io/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Union Find - Overview</title>
    <link href="http://testsiling.github.io/2021/02/02/al-union-find-0/"/>
    <id>http://testsiling.github.io/2021/02/02/al-union-find-0/</id>
    <published>2021-02-03T03:38:16.000Z</published>
    <updated>2021-02-03T03:38:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Union find is a algorithm that widly used in check connectivity in a graph. </p><span id="more"></span><p>Imagine connecting node as tree. Need to balance it while union and find, or else the time complexity for traversal would be O(N) instead of the height of the tree.</p><h2 id="Sample-Implementation"><a href="#Sample-Implementation" class="headerlink" title="Sample Implementation"></a>Sample Implementation</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="comment"># n disconnected node</span></span><br><span class="line">        <span class="comment"># number of tree</span></span><br><span class="line">        self.count = n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># the parent of each node</span></span><br><span class="line">        self.parent = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># size of each tree</span></span><br><span class="line">        self.size = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            self.parent[i] = i</span><br><span class="line">            self.size[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        connect p and q</span></span><br><span class="line"><span class="string">        Parameter:</span></span><br><span class="line"><span class="string">            p: int</span></span><br><span class="line"><span class="string">            q: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rootP = self.find(p)</span><br><span class="line">        rootQ = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> rootP == rootQ:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># for balance purpose </span></span><br><span class="line">        <span class="comment"># append the smaller party to the larger party</span></span><br><span class="line">        <span class="keyword">if</span> self.size[rootP] &gt; self.size[rootQ]:</span><br><span class="line">            self.parent[rootQ] = rootP</span><br><span class="line">            self.size[rootP] += self.size[rootQ]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.parent[rootP] = rootQ</span><br><span class="line">            self.size[rootQ] += self.size[rootQ]</span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        check connectivity between p and q</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.find(p) == self.find(q)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        find the root of x</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> self.parent[x] != x:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># balance the tree while finding</span></span><br><span class="line">            self.parent[x] = self.parent[self.parent[x]]</span><br><span class="line">            x = self.parent[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">wiki</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484751&amp;idx=1&amp;sn=a873c1f51d601bac17f5078c408cc3f6&amp;chksm=9bd7fb47aca07251dd9146e745b4cc5cfdbc527abe93767691732dfba166dfc02fbb7237ddbf&amp;scene=21#wechat_redirect">labuladong - union find (in Chinese)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Union find is a algorithm that widly used in check connectivity in a graph. &lt;/p&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Union Find" scheme="http://testsiling.github.io/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Data Structure - Trie - Overview</title>
    <link href="http://testsiling.github.io/2021/01/30/al-trie-0/"/>
    <id>http://testsiling.github.io/2021/01/30/al-trie-0/</id>
    <published>2021-01-30T20:34:22.000Z</published>
    <updated>2021-01-30T20:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>In computer science, a trie, also called digital tree or prefix tree, is a kind of search tree—an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings.</p><span id="more"></span><p><img src="/images/trie1.png" alt="tire"></p><h2 id="Implement-a-Basic-Trie"><a href="#Implement-a-Basic-Trie" class="headerlink" title="Implement a Basic Trie"></a>Implement a Basic Trie</h2><p>Great trie explaination:<br><a href="https://leetcode.com/problems/implement-trie-prefix-tree/solution/">https://leetcode.com/problems/implement-trie-prefix-tree/solution/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">next</span> = collections.defaultdict(TrieNode)</span><br><span class="line">        self.is_word = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            cur = cur.<span class="built_in">next</span>[w]</span><br><span class="line">        cur.is_word = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>[w]</span><br><span class="line">        <span class="keyword">return</span> cur.is_word</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="comment"># print(w, cur.next, cur.is_word)</span></span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>[w]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h3><p><strong>M</strong> is the length of the word</p><h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><ul><li>time: O(M)</li><li>space: O(M)</li></ul><h4 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h4><ul><li>time: O(M)</li><li>space: O(1)</li></ul><h2 id="Implement-a-Trie-with-Fuzzy-Search"><a href="#Implement-a-Trie-with-Fuzzy-Search" class="headerlink" title="Implement a Trie with Fuzzy Search"></a>Implement a Trie with Fuzzy Search</h2><p>A great article here:<br><a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/solution/">https://leetcode.com/problems/design-add-and-search-words-data-structure/solution/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">next</span> = collections.defaultdict(TrieNode)</span><br><span class="line">        self.isword = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addWord</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            cur = cur.<span class="built_in">next</span>[w]</span><br><span class="line">        cur.isword = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Fuzzy Search</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">match</span>(<span class="params">node, word</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(word):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> w == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="comment"># meet . search all children</span></span><br><span class="line">                    <span class="keyword">for</span> child <span class="keyword">in</span> node.<span class="built_in">next</span>.values():</span><br><span class="line">                        <span class="keyword">if</span> match(child, word[i+<span class="number">1</span>:]):</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">elif</span> w <span class="keyword">not</span> <span class="keyword">in</span> node.<span class="built_in">next</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.<span class="built_in">next</span>[w]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node.isword</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> match(self.root, word)</span><br></pre></td></tr></table></figure><h3 id="Complexity-1"><a href="#Complexity-1" class="headerlink" title="Complexity"></a>Complexity</h3><p><strong>M</strong> is the length of the word<br><strong>N</strong> is the number of keys in the trie</p><h4 id="Insert-1"><a href="#Insert-1" class="headerlink" title="Insert"></a>Insert</h4><ul><li>time: O(M)</li><li>space: O(M)</li></ul><h4 id="Search-1"><a href="#Search-1" class="headerlink" title="Search"></a>Search</h4><ul><li>time: O(N * 26^M)</li><li>space: O(M)</li></ul><p>Each word has 26 char, for M length of searched word, need to search 26^M times.<br>to search all keys, time complexity is O(N * 26^M)</p><h2 id="Double-Array-Trie"><a href="#Double-Array-Trie" class="headerlink" title="Double-Array Trie"></a>Double-Array Trie</h2><p>If the trie is static and huge, use Double-Array Trie is very fast to save/load and very fast to lookup. But insert/remove can be costly.<br><a href="https://linux.thai.net/~thep/datrie/">https://linux.thai.net/~thep/datrie/</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><p><a href="https://en.wikipedia.org/wiki/Trie">https://en.wikipedia.org/wiki/Trie</a><br><a href="https://leetcode.com/problems/implement-trie-prefix-tree/solution/">https://leetcode.com/problems/implement-trie-prefix-tree/solution/</a><br><a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/solution/">https://leetcode.com/problems/design-add-and-search-words-data-structure/solution/</a><br><a href="https://stackoverflow.com/questions/18963783/build-trie-faster">https://stackoverflow.com/questions/18963783/build-trie-faster</a><br><a href="https://linux.thai.net/~thep/datrie/">https://linux.thai.net/~thep/datrie/</a><br><a href="https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton">https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;In computer science, a trie, also called digital tree or prefix tree, is a kind of search tree—an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Trie" scheme="http://testsiling.github.io/tags/Trie/"/>
    
    <category term="Data Structure" scheme="http://testsiling.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Some Useful Tricks in Python 3</title>
    <link href="http://testsiling.github.io/2021/01/15/python2/"/>
    <id>http://testsiling.github.io/2021/01/15/python2/</id>
    <published>2021-01-16T03:38:21.000Z</published>
    <updated>2021-01-16T03:38:21.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>f-string</li><li>:= Walrus Operator</li></ul><span id="more"></span><h2 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Celine&#x27;</span></span><br><span class="line">score = <span class="number">123.4567</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">score</span> + <span class="title">x</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="params"><span class="string">f&#x27;name = <span class="subst">&#123;name&#125;</span>, score = <span class="subst">&#123;score:<span class="number">.3</span>f&#125;</span>&#x27;</span></span>)  # <span class="title">python</span> 3.6+</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="params"><span class="string">f&#x27;<span class="subst">&#123;name = &#125;</span>, <span class="subst">&#123;score = :<span class="number">.3</span>f&#125;</span>&#x27;</span></span>)  #<span class="title">python</span> 3.8+</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="params"><span class="string">f&#x27;<span class="subst">&#123;score = &#125;</span>, <span class="subst">&#123;plus(<span class="number">100</span>) = &#125;</span>&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure><p>I usually use the first one, just found the new feature in after 3.8.</p><h2 id=""><a href="#" class="headerlink" title=":="></a>:=</h2><p>:= Assignment Expressions (after 3.8)</p><h3 id="scenario-1-local-variable"><a href="#scenario-1-local-variable" class="headerlink" title="scenario 1: local variable"></a>scenario 1: local variable</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>] * <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># call len(a) twice</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(a) &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;list too long, <span class="subst">&#123;<span class="built_in">len</span>(a)&#125;</span> elements&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call len(a) once</span></span><br><span class="line">n = <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;list too long, <span class="subst">&#123;n&#125;</span> elements&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call len(a) once and assign it to x</span></span><br><span class="line"><span class="comment"># needs parenthesis, := piority lower than other operator</span></span><br><span class="line"><span class="keyword">if</span> (x := <span class="built_in">len</span>(a)) &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;list too long, <span class="subst">&#123;x&#125;</span> elements&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;list too long, <span class="subst">&#123;x&#125;</span> elements&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="scanrio-2-while-loop"><a href="#scanrio-2-while-loop" class="headerlink" title="scanrio 2: while loop"></a>scanrio 2: while loop</h3><p>read a string flow till the end.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># basic</span></span><br><span class="line">f1 = io.StringIO(<span class="string">&#x27;123456789&#x27;</span>)</span><br><span class="line">x1 = f1.read(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">while</span> x1:</span><br><span class="line">    <span class="built_in">print</span>(x1)</span><br><span class="line">    x1 = f1.read(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># better</span></span><br><span class="line">f2 = io.StringIO(<span class="string">&#x27;123456789&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> (x2 := f2.read(<span class="number">2</span>)) != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(x2)</span><br></pre></td></tr></table></figure></p><h3 id="scenario-3-in-list-comprehension"><a href="#scenario-3-in-list-comprehension" class="headerlink" title="scenario 3: in list comprehension"></a>scenario 3: in list comprehension</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">targets = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>]</span><br><span class="line">my = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Melon&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print all element in my list match in target list</span></span><br><span class="line"><span class="comment"># call lower() twice</span></span><br><span class="line">l1 = [f.lower() <span class="keyword">for</span> f <span class="keyword">in</span> my <span class="keyword">if</span> f.lower() <span class="keyword">in</span> targets]</span><br><span class="line"><span class="built_in">print</span>(l1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call lower() once</span></span><br><span class="line">l2 = [f <span class="keyword">for</span> fruit <span class="keyword">in</span> my <span class="keyword">if</span> (f:= fruit.lower()) <span class="keyword">in</span> targets]</span><br><span class="line"><span class="built_in">print</span>(l2)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;f-string&lt;/li&gt;
&lt;li&gt;:= Walrus Operator&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Design (1)</title>
    <link href="http://testsiling.github.io/2021/01/12/al-design-1/"/>
    <id>http://testsiling.github.io/2021/01/12/al-design-1/</id>
    <published>2021-01-13T02:40:35.000Z</published>
    <updated>2021-01-13T02:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Data Structure Design Problem Set (1)</p><ul><li>146.LRU Cache</li><li>284.Peeking Iterator</li><li>341.Flatten Nested List Iterator</li><li>295.Find Median from Data Stream</li></ul><span id="more"></span><h2 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a>146. LRU Cache</h2><p>Design Least Recently Used (LRU) Cache<br>Use double-linked list as cache, disconnect the old node and reconnect it to the tail of the list when <code>get</code> an value. add new node to the tail and drop the first (the least used) node if exceed capacity.<br>use a dictionary to log {key: node}<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k=<span class="number">0</span>, v=<span class="number">0</span></span>):</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.v = v</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.head = Node()</span><br><span class="line">        self.tail = Node()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.<span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">        self.cap = capacity</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_remove</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="comment"># remove the least used node</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        last = self.tail.prev</span><br><span class="line">        self.tail.prev = node</span><br><span class="line">        last.<span class="built_in">next</span> = node</span><br><span class="line">        node.<span class="built_in">next</span> = self.tail</span><br><span class="line">        node.prev = last</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># move recent used node to tail</span></span><br><span class="line">        node = self.<span class="built_in">dict</span>[key]</span><br><span class="line">        self._remove(node)</span><br><span class="line">        self._add(node)</span><br><span class="line">        <span class="keyword">return</span> node.v</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="comment"># remove the existed key first, we will add new anyway</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            node = self.<span class="built_in">dict</span>[key]</span><br><span class="line">            self._remove(node)</span><br><span class="line">            <span class="keyword">del</span> self.<span class="built_in">dict</span>[key]</span><br><span class="line">        </span><br><span class="line">        node = Node(key, value)</span><br><span class="line">        self._add(node)</span><br><span class="line">        self.<span class="built_in">dict</span>[key] = node</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.<span class="built_in">dict</span>) &gt; self.cap:</span><br><span class="line">            least = self.head.<span class="built_in">next</span></span><br><span class="line">            self._remove(least)</span><br><span class="line">            <span class="keyword">del</span> self.<span class="built_in">dict</span>[least.k]</span><br></pre></td></tr></table></figure></p><h2 id="284-Peeking-Iterator"><a href="#284-Peeking-Iterator" class="headerlink" title="284. Peeking Iterator"></a>284. Peeking Iterator</h2><p>My initial idea was create a one-way linked list, or initialize a normal list, which is too easy. But if so, it lose the meaning as iterator. Then I second thought, I don’t even need a list, I just need a buffer for the peak value.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekingIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, iterator</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        :type iterator: Iterator</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._iterator = iterator</span><br><span class="line">        self._peak = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._peak <span class="keyword">and</span> self._iterator.hasNext():</span><br><span class="line">            self._peak = self._iterator.<span class="built_in">next</span>()</span><br><span class="line">        <span class="keyword">return</span> self._peak</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._peak:</span><br><span class="line">            peak = self._peak</span><br><span class="line">            self._peak = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> peak</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self._iterator.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._peak:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self._iterator.hasNext()</span><br></pre></td></tr></table></figure></p><h2 id="341-Flatten-Nested-List-Iterator"><a href="#341-Flatten-Nested-List-Iterator" class="headerlink" title="341. Flatten Nested List Iterator"></a>341. Flatten Nested List Iterator</h2><p>Flatten nested list in init. Use deque to faster pop the first element.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nestedList: [NestedInteger]</span>):</span></span><br><span class="line">        self.ls = deque()</span><br><span class="line">        self.flatten(nestedList)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, nestedList</span>):</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> nestedList:</span><br><span class="line">            <span class="keyword">if</span> l.isInteger():</span><br><span class="line">                self.ls.append(l.getInteger())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.flatten(l.getList())      </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.ls.popleft() <span class="keyword">if</span> self.hasNext <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.ls) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h2 id="295-Find-Median-from-Data-Stream"><a href="#295-Find-Median-from-Data-Stream" class="headerlink" title="295. Find Median from Data Stream"></a>295. Find Median from Data Stream</h2><p>Dividing data into 2 heaps (length as equal as possible):</p><ul><li>Use max heap to store a chunk of smaller elements</li><li>Use min heap to store another chunk of larger elements.<br>Reference:<br><a href="https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg">https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.small = []  <span class="comment"># store smaller data, maxHeap</span></span><br><span class="line">        self.large = []  <span class="comment"># store larger data, minHeap</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># insert into large</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.small) &gt;= <span class="built_in">len</span>(self.large):</span><br><span class="line">            heapq.heappush(self.small, -num)</span><br><span class="line">            heapq.heappush(self.large, -heapq.heappop(self.small))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self.large, num)</span><br><span class="line">            heapq.heappush(self.small, -heapq.heappop(self.large))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.small) &gt; <span class="built_in">len</span>(self.large):</span><br><span class="line">            <span class="keyword">return</span>  -self.small[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(self.large) &gt; <span class="built_in">len</span>(self.small):</span><br><span class="line">            <span class="keyword">return</span> self.large[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># even len</span></span><br><span class="line">            <span class="keyword">return</span> (-self.small[<span class="number">0</span>] + self.large[<span class="number">0</span>]) / <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Data Structure Design Problem Set (1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;146.LRU Cache&lt;/li&gt;
&lt;li&gt;284.Peeking Iterator&lt;/li&gt;
&lt;li&gt;341.Flatten Nested List Iterator&lt;/li&gt;
&lt;li&gt;295.Find Median from Data Stream&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Data Structure" scheme="http://testsiling.github.io/tags/Data-Structure/"/>
    
    <category term="Design" scheme="http://testsiling.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Dynamic Programming (3) - Buy &amp; Sell Stock!</title>
    <link href="http://testsiling.github.io/2021/01/10/al-dp-3/"/>
    <id>http://testsiling.github.io/2021/01/10/al-dp-3/</id>
    <published>2021-01-10T19:54:15.000Z</published>
    <updated>2021-01-10T19:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Best-Time-to-Buy-and-Sell-Stock-Problem-Set"><a href="#Best-Time-to-Buy-and-Sell-Stock-Problem-Set" class="headerlink" title="[Best Time to Buy and Sell Stock] Problem Set"></a>[Best Time to Buy and Sell Stock] Problem Set</h1><p>Leetcode Dynamic Programming Problem Set (3)</p><ul><li>121.Best Time to Buy and Sell Stock</li><li>122.Best Time to Buy and Sell Stock II</li><li>123.Best Time to Buy and Sell Stock III</li><li>188.Best Time to Buy and Sell Stock IV</li><li>309.Best Time to Buy and Sell Stock with Cooldown</li><li>714.Best Time to Buy and Sell Stock with Transaction Fee</li></ul><span id="more"></span><p>There are 3 options in each trade day: <strong>buy, sell, hold</strong><br>We can use a 3d array to log all situations:<br><code>dp[i][k][1 or 0]</code> = <code>the maximum profit at the end of the i-th day with at most k transactions and with 0 or 1 stock in our hand AFTER taking the action</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># either always haven&#x27;t got stock, or sold a stock. </span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># either I kept the existed stock, or bought one.</span></span><br><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Base case：dp[-1] means before day 0, haven&#x27;t start yet.</span></span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Recurrence relations:</span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h2><p>k = 1.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    buy = prices[<span class="number">0</span>]</span><br><span class="line">    profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">        buy = <span class="built_in">min</span>(prices[i], buy)</span><br><span class="line">        profit = <span class="built_in">max</span>(profit, prices[i] - buy)</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure></p><h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h2><p>k = inf<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    last_buy = -prices[<span class="number">0</span>]  <span class="comment"># have one stock, either bought or kept</span></span><br><span class="line">    last_sell = <span class="number">0</span>  <span class="comment"># have no stock, either sold or kept</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">        cur_buy = <span class="built_in">max</span>(last_buy, last_sell - prices[i])</span><br><span class="line">        cur_sell = <span class="built_in">max</span>(last_sell, last_buy+ prices[i])</span><br><span class="line">        last_buy = cur_buy</span><br><span class="line">        last_sell = cur_sell</span><br><span class="line">    <span class="keyword">return</span> last_sell</span><br></pre></td></tr></table></figure></p><h2 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a>123. Best Time to Buy and Sell Stock III</h2><p>k = 2<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="comment"># last_k_numberOfStock</span></span><br><span class="line">    gain_1_1, gain_2_1 = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    gain_1_0, gain_2_0 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        gain_2_0 = <span class="built_in">max</span>(gain_2_0, gain_2_1 + p)</span><br><span class="line">        gain_2_1 = <span class="built_in">max</span>(gain_2_1, gain_1_0 - p)</span><br><span class="line">        gain_1_0 = <span class="built_in">max</span>(gain_1_0, gain_1_1 + p)</span><br><span class="line">        gain_1_1 = <span class="built_in">max</span>(gain_1_1, -p)</span><br><span class="line">    <span class="keyword">return</span> gain_2_0</span><br></pre></td></tr></table></figure></p><h2 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. Best Time to Buy and Sell Stock IV"></a>188. Best Time to Buy and Sell Stock IV</h2><p>k = inf<br>The most general case. Very hard to understand<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt; <span class="number">2</span> <span class="keyword">or</span> <span class="keyword">not</span> k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        k = <span class="built_in">min</span>(k, n // <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        stock0 = [<span class="number">0</span>] * (k + <span class="number">1</span>)</span><br><span class="line">        stock1 = [<span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)] * (k + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                stock0[j] = <span class="built_in">max</span>(stock0[j], stock1[j] + price)</span><br><span class="line">                stock1[j] = <span class="built_in">max</span>(stock1[j], stock0[j-<span class="number">1</span>] - price)</span><br><span class="line">        <span class="keyword">return</span> stock0[k]</span><br></pre></td></tr></table></figure></p><h2 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a>309. Best Time to Buy and Sell Stock with Cooldown</h2><p>k = inf + cooldown<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    buy = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    sell = <span class="number">0</span></span><br><span class="line">    prev_sell = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        temp = sell</span><br><span class="line">        sell = <span class="built_in">max</span>(sell, buy + p)</span><br><span class="line">        buy = <span class="built_in">max</span>(buy, prev_sell - p)</span><br><span class="line">        prev_sell = temp</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sell</span><br></pre></td></tr></table></figure></p><h2 id="714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="714. Best Time to Buy and Sell Stock with Transaction Fee"></a>714. Best Time to Buy and Sell Stock with Transaction Fee</h2><p>The same as <strong>Best Time to Buy and Sell Stock II</strong>, just need to deduct fee from profit.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    buy = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    sell = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        sell = <span class="built_in">max</span>(sell, buy + p - fee)</span><br><span class="line">        buy = <span class="built_in">max</span>(buy, sell - p)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sell</span><br></pre></td></tr></table></figure></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems">Most consistent ways of dealing with the series of stock problems</a></p></li><li><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75927/share-my-thinking-process">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75927/share-my-thinking-process</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Best-Time-to-Buy-and-Sell-Stock-Problem-Set&quot;&gt;&lt;a href=&quot;#Best-Time-to-Buy-and-Sell-Stock-Problem-Set&quot; class=&quot;headerlink&quot; title=&quot;[Best Time to Buy and Sell Stock] Problem Set&quot;&gt;&lt;/a&gt;[Best Time to Buy and Sell Stock] Problem Set&lt;/h1&gt;&lt;p&gt;Leetcode Dynamic Programming Problem Set (3)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;121.Best Time to Buy and Sell Stock&lt;/li&gt;
&lt;li&gt;122.Best Time to Buy and Sell Stock II&lt;/li&gt;
&lt;li&gt;123.Best Time to Buy and Sell Stock III&lt;/li&gt;
&lt;li&gt;188.Best Time to Buy and Sell Stock IV&lt;/li&gt;
&lt;li&gt;309.Best Time to Buy and Sell Stock with Cooldown&lt;/li&gt;
&lt;li&gt;714.Best Time to Buy and Sell Stock with Transaction Fee&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://testsiling.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Dynamic Programming (2)</title>
    <link href="http://testsiling.github.io/2021/01/06/al-dp-2/"/>
    <id>http://testsiling.github.io/2021/01/06/al-dp-2/</id>
    <published>2021-01-07T02:26:49.000Z</published>
    <updated>2021-01-07T02:26:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Dynamic Programming Problem Collection (2)</p><ul><li>322.Coin Change</li><li>55.Jump Game</li><li>62.Unique Paths</li><li>300.Longest Increasing Subsequence</li><li>91.Decode Way</li></ul><span id="more"></span><h2 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h2><p>for example coins = [1,2,5], x = 11<br>Three cases for selecting the last coin:</p><ol><li>the last coin is $1, f(x) = f(x - 1) + 1</li><li>the last coin is $2, f(x) = f(x - 2) + 1</li><li>the last coin is $5, f(x) = f(x - 5) + 1</li></ol><p>Hense, <code>f(x) = min(f(x - 1), f(x - 2), f(x - 5)) + 1</code><br>we can use recursion to eaisly get the global optimized result, with lot of redandunt calculation (TLE)<br>Or we can pre-calculate and save f(0) ~ f(x), to avoid repeating calculation.<br><code>f(0) = 0</code> is the base case. <code>x - coin &lt; 0</code> is invalid, for instance, f(1) = -1, no result. </p><h3 id="Bottom-up"><a href="#Bottom-up" class="headerlink" title="Bottom up"></a>Bottom up</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = [amount + <span class="number">1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp)):</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> i - coin &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1</span> + dp[i - coin])</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> dp[amount] == amount + <span class="number">1</span> <span class="keyword">else</span> dp[amount]</span><br></pre></td></tr></table></figure><h3 id="Top-down"><a href="#Top-down" class="headerlink" title="Top down"></a>Top down</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">amount</span>):</span></span><br><span class="line">        <span class="keyword">if</span> amount <span class="keyword">in</span> found:</span><br><span class="line">            <span class="keyword">return</span> found[amount]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            cur = change(amount - coin)</span><br><span class="line">            <span class="keyword">if</span> cur != -<span class="number">1</span>:</span><br><span class="line">                res = <span class="built_in">min</span>(res, <span class="number">1</span> + cur)</span><br><span class="line">        </span><br><span class="line">        found[amount] = res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    found = &#123;&#125;</span><br><span class="line">    change(amount)</span><br><span class="line">    <span class="keyword">return</span> found[amount] <span class="keyword">if</span> amount != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a>55. Jump Game</h2><p>This is a top-down solution. start the the second last element, if <code>nums[i] + i &gt;= last element</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    last = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># from the second last element</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i) &gt;= last:</span><br><span class="line">            last = i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> last == <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h2><p>If you draw the board, for example m = 3, n = 7, then fill in the number of ways you can get to that a cell, the right-bottom coner is thr right resule. A bottom-up solution.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 1, 1,  1,  1,  1</span><br><span class="line">1, 2, 3, 4,  5,  6,  7</span><br><span class="line">1, 3, 6, 10, 15, 21, 28</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    paths = [[<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            paths[r][c] = paths[r - <span class="number">1</span>][c] + paths[r][c - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> paths[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><h2 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h2><p>I don’t think anyone can really thinkof the greedy + binary search solution. Probaly excepting the author, and pro poker players?<br>Anyway, here’s the DP solution. Time complexity is O(n^2). dp table logs the LIS ending with <code>nums[i]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        res = <span class="built_in">max</span>(res, dp[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="91-Decode-Way"><a href="#91-Decode-Way" class="headerlink" title="91. Decode Way"></a>91. Decode Way</h2><p>Recursion with memorization. If you draw down the decision tree, that will be pretty straightward.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[s]</span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        ways = decode(s[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(s[:<span class="number">2</span>]) &lt;= <span class="number">26</span>:</span><br><span class="line">            ways += decode(s[<span class="number">2</span>:])</span><br><span class="line">        memo[s] = ways</span><br><span class="line">        <span class="keyword">return</span> ways</span><br><span class="line">    </span><br><span class="line">    memo = &#123;<span class="string">&#x27;&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> decode(s)</span><br></pre></td></tr></table></figure></p><p>DP<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(s) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    dp = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] += s[<span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    dp[<span class="number">1</span>] += <span class="number">10</span> &lt;= <span class="built_in">int</span>(s[:<span class="number">2</span>]) &lt;= <span class="number">26</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># single digit</span></span><br><span class="line">        <span class="keyword">if</span> s[i] != <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># double digits</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">10</span> &lt;= <span class="built_in">int</span>(s[i - <span class="number">1</span> : i + <span class="number">1</span>]) &lt;= <span class="number">26</span>:</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Dynamic Programming Problem Collection (2)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;322.Coin Change&lt;/li&gt;
&lt;li&gt;55.Jump Game&lt;/li&gt;
&lt;li&gt;62.Unique Paths&lt;/li&gt;
&lt;li&gt;300.Longest Increasing Subsequence&lt;/li&gt;
&lt;li&gt;91.Decode Way&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://testsiling.github.io/tags/Dynamic-Programming/"/>
    
    <category term="Greedy" scheme="http://testsiling.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Two Pointers (2)</title>
    <link href="http://testsiling.github.io/2021/01/03/al-two-pointers-2/"/>
    <id>http://testsiling.github.io/2021/01/03/al-two-pointers-2/</id>
    <published>2021-01-04T00:47:23.000Z</published>
    <updated>2021-01-04T00:47:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Two pointers problem set (2)</p><ul><li>11.Container With Most Water</li><li>532.K-diff Pairs in an Array</li></ul><p>N Sum problem set:</p><ul><li>1.Two Sum</li><li>167.Two Sum II - Input array is sorted</li><li>15.3Sum</li><li>16.3Sum Closest</li><li>18.4Sum</li></ul><span id="more"></span><h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        cur = (right - left) * <span class="built_in">min</span>(height[left], height[right])</span><br><span class="line">        res = <span class="built_in">max</span>(cur, res)</span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="532-K-diff-Pairs-in-an-Array"><a href="#532-K-diff-Pairs-in-an-Array" class="headerlink" title="532. K-diff Pairs in an Array"></a>532. K-diff Pairs in an Array</h2><h3 id="Two-Pointers"><a href="#Two-Pointers" class="headerlink" title="Two Pointers"></a>Two Pointers</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    l, r = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> r &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> l &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> l == r <span class="keyword">or</span> (nums[r] - nums[l]) &lt; k:</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[r] - nums[l] &gt; k:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h3><p>Much eaiser than two pointers solution, time is O(n)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    counter = Counter(nums)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> counter:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">and</span> counter[x] &gt; <span class="number">1</span>:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> x + k <span class="keyword">in</span> counter:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="N-Sum-Problem"><a href="#N-Sum-Problem" class="headerlink" title="N Sum Problem:"></a>N Sum Problem:</h2><h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h3><p>Unsort array, use hash map<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">return</span> [dic[n], i]</span><br><span class="line">        dic[target - n] = i</span><br></pre></td></tr></table></figure></p><h3 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="167. Two Sum II - Input array is sorted"></a>167. Two Sum II - Input array is sorted</h3><p>Sorted array use 2 pointers<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    lo, hi = <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        cur = numbers[lo] + numbers[hi]</span><br><span class="line">        <span class="keyword">if</span> cur == target:</span><br><span class="line">            <span class="keyword">return</span> (lo + <span class="number">1</span>, hi + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> cur &lt; target:</span><br><span class="line">            lo += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hi -= <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h3 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h3><h4 id="Two-Pointers-1"><a href="#Two-Pointers-1" class="headerlink" title="Two Pointers"></a>Two Pointers</h4><p>Remember to skip duplicate result.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums, target, start</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        lo, hi = start, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            cur = nums[lo] + nums[hi]</span><br><span class="line">            <span class="keyword">if</span> cur &lt; target:</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]:</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur &gt; target:</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]:</span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([nums[lo], nums[hi]])</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]:</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]:</span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) - <span class="number">2</span>:</span><br><span class="line">        two_sums = twoSum(nums, -nums[i], i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> two_sums:</span><br><span class="line">            res.append([nums[i]] + s)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) - <span class="number">2</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h4 id="Hashmap-1"><a href="#Hashmap-1" class="headerlink" title="Hashmap"></a>Hashmap</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums, target, res</span>):</span></span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            x = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> seen:</span><br><span class="line">                res.append([-target, nums[i], x])</span><br><span class="line">                <span class="keyword">while</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            seen.add(nums[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># all following nums are greater than 0</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> nums[i - <span class="number">1</span>] != nums[i]:</span><br><span class="line">            twoSum(nums[i + <span class="number">1</span>:], -nums[i], res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h3><p>Similar with 3Sum<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums, target, start</span>):</span></span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        diff = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        lo, hi = start, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            cur = nums[lo] + nums[hi]</span><br><span class="line">            <span class="keyword">if</span> cur == target:</span><br><span class="line">                <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line">            cur_diff = <span class="built_in">abs</span>(target - cur)</span><br><span class="line">            <span class="keyword">if</span> cur_diff &lt; diff:</span><br><span class="line">                res = cur</span><br><span class="line">                diff = cur_diff</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur &lt; target:</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    nums.sort()</span><br><span class="line">    res = <span class="literal">None</span></span><br><span class="line">    diff = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">        cur_sum = nums[i] + twoSum(nums, target - nums[i], i + <span class="number">1</span>)</span><br><span class="line">        cur_diff = <span class="built_in">abs</span>(target - cur_sum)</span><br><span class="line">        <span class="keyword">if</span> cur_diff == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> cur_sum</span><br><span class="line">        <span class="keyword">if</span> cur_diff &lt; diff:</span><br><span class="line">            res = cur_sum</span><br><span class="line">            diff = cur_diff</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h3><p>The same as 3 sum.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target, start</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        lo, hi = start, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            cur = nums[lo] + nums[hi]</span><br><span class="line">            <span class="keyword">if</span> cur &lt; target:</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]:</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur &gt; target:</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]:</span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([nums[lo], nums[hi]])</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]:</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]:</span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target, start, </span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        i = start</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) - <span class="number">2</span>:</span><br><span class="line">            two_sums = self.twoSum(nums, target - nums[i], i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> two_sums:</span><br><span class="line">                res.append([nums[i]] + s)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) - <span class="number">2</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) - <span class="number">3</span>:</span><br><span class="line">            triples = self.threeSum(nums, target - nums[i], i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> triples:</span><br><span class="line">                res.append([nums[i]] + t)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) - <span class="number">3</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>But, we can generlize it to a N Sum function</p><h3 id="N-Sum"><a href="#N-Sum" class="headerlink" title="N Sum"></a>N Sum</h3><p>The list <code>nums</code> should sort outside of the function, or else the list will resort in every recursion.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nSum</span>(<span class="params">self, nums, target, n, start=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="comment"># nums.sort()  # assume the nums is sorted.</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2 sum is base case.</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums) &lt; n:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            lo, hi = start, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">                cur = nums[lo] + nums[hi]</span><br><span class="line">                <span class="keyword">if</span> cur &lt; target:</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]:</span><br><span class="line">                        lo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> cur &gt; target:</span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]:</span><br><span class="line">                        hi -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[lo], nums[hi]])</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]:</span><br><span class="line">                        lo += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> lo &lt; hi <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]:</span><br><span class="line">                        hi -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        i = start</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) - (n - <span class="number">1</span>):</span><br><span class="line">            nsum = self.nSum(nums, target - nums[i], n - <span class="number">1</span>, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> nsum:</span><br><span class="line">                res.append([nums[i]] + s)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) - (n - <span class="number">1</span>) <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>So, for the four sum problem, just simplly call<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">return</span> self.nSum(nums, target, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Two pointers problem set (2)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;11.Container With Most Water&lt;/li&gt;
&lt;li&gt;532.K-diff Pairs in an Array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;N Sum problem set:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.Two Sum&lt;/li&gt;
&lt;li&gt;167.Two Sum II - Input array is sorted&lt;/li&gt;
&lt;li&gt;15.3Sum&lt;/li&gt;
&lt;li&gt;16.3Sum Closest&lt;/li&gt;
&lt;li&gt;18.4Sum&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Two Pointers" scheme="http://testsiling.github.io/tags/Two-Pointers/"/>
    
    <category term="Sliding windows" scheme="http://testsiling.github.io/tags/Sliding-windows/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Two Pointers (1) - Sliding Window</title>
    <link href="http://testsiling.github.io/2021/01/01/al-two-pointers-1/"/>
    <id>http://testsiling.github.io/2021/01/01/al-two-pointers-1/</id>
    <published>2021-01-01T18:14:47.000Z</published>
    <updated>2021-01-01T18:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Two pointers problem set (1) - Sliding Window</p><ul><li>76.Minimum Window Substring</li><li>567.Permutation in String</li><li>438.Find All Anagrams in a String</li><li>3.Longest Substring Without Repeating Characters</li><li>239.Sliding Window Maximum</li></ul><span id="more"></span><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find string t in string s</span></span><br><span class="line"><span class="keyword">from</span> collection <span class="keyword">import</span> Counter, defaultdict</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sliding_window</span>(<span class="params">s, t</span>):</span></span><br><span class="line">need = Counter(t)</span><br><span class="line">valid = <span class="number">0</span></span><br><span class="line">left = right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">c = s[right]</span><br><span class="line">right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># do something</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> window needs shrink:</span><br><span class="line">d = s[left]</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line"><span class="comment"># do something</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a>76. Minimum Window Substring</h2><ol><li>Extend right pointer until all characters found</li><li>Log smallest window</li><li>Shrink left pointer until found the next valid window</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    needs = <span class="built_in">dict</span>(Counter(t))</span><br><span class="line">    left = right = <span class="number">0</span></span><br><span class="line">    counter = <span class="built_in">len</span>(t)</span><br><span class="line">    min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># search [left. right)</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        </span><br><span class="line">        c = s[right]</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> needs:</span><br><span class="line">        <span class="comment"># is a valid character</span></span><br><span class="line">        needs[c] -= <span class="number">1</span></span><br><span class="line">            counter -= needs[c] &gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> counter:</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># update res</span></span><br><span class="line">            <span class="keyword">if</span> (right - left) &lt; min_len:</span><br><span class="line">                min_len = right - left</span><br><span class="line">                res = s[left: right]</span><br><span class="line">            </span><br><span class="line">            c = s[left]</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> needs:</span><br><span class="line">                needs[c] += <span class="number">1</span></span><br><span class="line">                counter += needs[c] &gt; <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="567-Permutation-in-String"><a href="#567-Permutation-in-String" class="headerlink" title="567. Permutation in String"></a>567. Permutation in String</h2><p>True criteria is <code>len(s1) == window size</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    </span><br><span class="line">    needs = Counter(s1)</span><br><span class="line">    counter = <span class="built_in">len</span>(s1)</span><br><span class="line">    </span><br><span class="line">    left = right = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s2):</span><br><span class="line">        </span><br><span class="line">        c = s2[right]</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> needs:</span><br><span class="line">            needs[c] -= <span class="number">1</span></span><br><span class="line">            counter -= needs[c] &gt;= <span class="number">0</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> counter:</span><br><span class="line">            <span class="keyword">if</span> right - left == <span class="built_in">len</span>(s1):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            c = s2[left]</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> needs:</span><br><span class="line">                needs[c] += <span class="number">1</span></span><br><span class="line">                counter += needs[c] &gt; <span class="number">0</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><h2 id="438-Find-All-Anagrams-in-a-String"><a href="#438-Find-All-Anagrams-in-a-String" class="headerlink" title="438. Find All Anagrams in a String"></a>438. Find All Anagrams in a String</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    needs = Counter(p)</span><br><span class="line">    counter = <span class="built_in">len</span>(p)</span><br><span class="line">    left = right = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        c = s[right]</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> needs:</span><br><span class="line">            needs[c] -= <span class="number">1</span></span><br><span class="line">            counter -= needs[c] &gt;= <span class="number">0</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># is a valid window</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> counter:</span><br><span class="line">            c = s[left]</span><br><span class="line">            <span class="keyword">if</span> (right - left) == <span class="built_in">len</span>(p):</span><br><span class="line">                res.append(left)</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> needs:</span><br><span class="line">                needs[c] += <span class="number">1</span></span><br><span class="line">                counter += needs[c] &gt; <span class="number">0</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    </span><br><span class="line">    cur = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    left = right = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        cur[s[right]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur[s[right]] &gt; <span class="number">1</span>:</span><br><span class="line">            cur[s[left]] -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure><h2 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a>239. Sliding Window Maximum</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">window_push</span>(<span class="params">n</span>):</span></span><br><span class="line">        <span class="comment"># delete all element less than n</span></span><br><span class="line">        <span class="keyword">while</span> window <span class="keyword">and</span> window[-<span class="number">1</span>] &lt; n:</span><br><span class="line">            window.pop()</span><br><span class="line">        window.append(n)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">window_get_max</span>():</span></span><br><span class="line">        <span class="keyword">return</span> window[<span class="number">0</span>] <span class="keyword">if</span> window <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">window_pop</span>(<span class="params">n</span>):</span></span><br><span class="line">        <span class="keyword">return</span> window.popleft() <span class="keyword">if</span> window <span class="keyword">and</span> n == window[<span class="number">0</span>] <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    window = deque([])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        window_push(n)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># generate res when i &gt;= k - 1</span></span><br><span class="line">            res.append(window_get_max())</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># remove left</span></span><br><span class="line">            window_pop(nums[i - k + <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Two pointers problem set (1) - Sliding Window&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;76.Minimum Window Substring&lt;/li&gt;
&lt;li&gt;567.Permutation in String&lt;/li&gt;
&lt;li&gt;438.Find All Anagrams in a String&lt;/li&gt;
&lt;li&gt;3.Longest Substring Without Repeating Characters&lt;/li&gt;
&lt;li&gt;239.Sliding Window Maximum&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Two Pointers" scheme="http://testsiling.github.io/tags/Two-Pointers/"/>
    
    <category term="Sliding windows" scheme="http://testsiling.github.io/tags/Sliding-windows/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Binary Search (2)</title>
    <link href="http://testsiling.github.io/2020/12/30/al-binary-search-2/"/>
    <id>http://testsiling.github.io/2020/12/30/al-binary-search-2/</id>
    <published>2020-12-31T00:12:56.000Z</published>
    <updated>2020-12-31T00:12:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Binary Search Problem Set (2) - Hard</p><ul><li>410.Split Array Largest Sum</li></ul><span id="more"></span><h2 id="410-Split-Array-Largest-Sum"><a href="#410-Split-Array-Largest-Sum" class="headerlink" title="410. Split Array Largest Sum"></a>410. Split Array Largest Sum</h2><p>min largest sum in range: <code>[max(nums), sum(nums) + 1)</code><br>Basic idea is directly search the correct answer.</p><p>Given upper bound [max_sum], calculate the number of subarray that nums need to split into [cnt]<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if cnt &gt; m:  # given max_sum is too small</span><br><span class="line">    lo = max_sum + 1</span><br><span class="line">else:</span><br><span class="line">    hi = max_sum</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitable</span>(<span class="params">max_sum</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        split nums into k groups, sum of each group &lt;= max_sum</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            cur_sum += n</span><br><span class="line">            <span class="keyword">if</span> cur_sum &gt; max_sum:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                cur_sum = n</span><br><span class="line">                <span class="keyword">if</span> cnt &gt; m:  <span class="comment"># max_sum too small</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    lo = <span class="built_in">max</span>(nums)</span><br><span class="line">    hi = <span class="built_in">sum</span>(nums) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        max_sum = lo + (hi - lo ) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> splitable(max_sum):</span><br><span class="line">            lo = max_sum + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hi = max_sum</span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Binary Search Problem Set (2) - Hard&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;410.Split Array Largest Sum&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Binary Search" scheme="http://testsiling.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Binary Search (1)</title>
    <link href="http://testsiling.github.io/2020/12/29/al-binary-search-1/"/>
    <id>http://testsiling.github.io/2020/12/29/al-binary-search-1/</id>
    <published>2020-12-29T20:07:05.000Z</published>
    <updated>2020-12-29T20:07:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>Classic binary search scenarios are find a number, and find boundaries.<br>Leetcode Binary Search Problem Set (1) - Medium</p><ul><li>278.First Bad Version</li><li>33.Search in Rotated Sorted Array</li><li>1283.Find the Smallest Divisor Given a Threshold</li><li>875.Koko Eating Bananas</li><li>1011.Capacity To Ship Packages Within D Days</li><li>981.Time Based Key-Value Store<span id="more"></span></li></ul><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = ...</span><br><span class="line">    <span class="keyword">while</span> ...:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = ...</span><br><span class="line">    <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure><ul><li><em>Using <strong>elif</strong> instead of <strong>else</strong> in binary search can show more details, which is better for beginner to debug.</em></li><li><em><code>left + (right - left) / 2</code> is the same as <code>(right + left) / 2</code>, is avoiding int overflow. Python int won’t overflow though.</em></li></ul><h3 id="Find-a-number"><a href="#Find-a-number" class="headerlink" title="Find a number"></a>Find a number</h3><p>Search interval <strong>[left, right]</strong>, <code>left == right + 1</code> is the terminal criteria, which is an empty interval.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums, target</span>):</span></span><br><span class="line"></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># the last element</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line"></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">        <span class="comment"># search[mid + 1, right]</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># search [left, mid - 1]</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="Find-Left-Boundary"><a href="#Find-Left-Boundary" class="headerlink" title="Find Left Boundary"></a>Find Left Boundary</h3><p>Search <code>[left, right)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_left_bound</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line"></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p>Shrink right bound to get the </p><h3 id="Find-Right-Boundary"><a href="#Find-Right-Boundary" class="headerlink" title="Find Right Boundary"></a>Find Right Boundary</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_right_bound</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line"></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="278-First-Bad-Version"><a href="#278-First-Bad-Version" class="headerlink" title="278. First Bad Version"></a>278. First Bad Version</h2><p>Finding the left bound of bad version interval<br>[G, G, G, G, G, G, G, B, B, B] =&gt; serch =&gt; [B, B, B]</p><p>The left pointer should point to the first bad version.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left = <span class="number">1</span></span><br><span class="line">    right = n</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isBadVersion(mid):</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure></p><h2 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. Search in Rotated Sorted Array</h2><p>Use binary search 2 times: </p><ol><li>find pivot (actually is find left bound)</li><li>find target number. </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> nums[left] &gt; nums[right]:</span><br><span class="line">        <span class="comment"># search pivot in [left, right)</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line"></span><br><span class="line">        p = left</span><br><span class="line">        <span class="comment"># search left</span></span><br><span class="line">        <span class="keyword">if</span> target &gt;= nums[<span class="number">0</span>]:</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = p - <span class="number">1</span></span><br><span class="line">        <span class="comment"># search right</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = p</span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1283-Find-the-Smallest-Divisor-Given-a-Threshold"><a href="#1283-Find-the-Smallest-Divisor-Given-a-Threshold" class="headerlink" title="1283. Find the Smallest Divisor Given a Threshold"></a>1283. Find the Smallest Divisor Given a Threshold</h2><p>divisor range: <em>[1, max(nums)]</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallestDivisor</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    lo = <span class="number">1</span></span><br><span class="line">    hi = <span class="built_in">max</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = lo + (hi - lo) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>([ceil(n / mid) <span class="keyword">for</span> n <span class="keyword">in</span> nums]) &gt; threshold:</span><br><span class="line">            <span class="comment"># divisor too small</span></span><br><span class="line">            lo = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hi = mid</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure></p><h2 id="875-Koko-Eating-Bananas"><a href="#875-Koko-Eating-Bananas" class="headerlink" title="875. Koko Eating Bananas"></a>875. Koko Eating Bananas</h2><p>Typical find a number problem.<br>When jump out of the loop, left == right + 1, is the max number KOKO should eat.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span>(<span class="params">self, piles: <span class="type">List</span>[<span class="built_in">int</span>], H: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    left = <span class="number">1</span></span><br><span class="line">    right = <span class="built_in">max</span>(piles)  <span class="comment"># 1 pile / h</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        cur = <span class="built_in">sum</span>([ceil(p / mid) <span class="keyword">for</span> p <span class="keyword">in</span> piles])</span><br><span class="line">        <span class="keyword">if</span> cur == H:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> cur &gt; H:</span><br><span class="line">            <span class="comment"># need less time, eat more banana each time</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="comment"># left == right + 1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure></p><h2 id="1011-Capacity-To-Ship-Packages-Within-D-Days"><a href="#1011-Capacity-To-Ship-Packages-Within-D-Days" class="headerlink" title="1011. Capacity To Ship Packages Within D Days"></a>1011. Capacity To Ship Packages Within D Days</h2><p>Left bound: max -&gt; as least can move the heaviest item<br>Right bound: sum -&gt; move all in one day<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shipWithinDays</span>(<span class="params">self, weights: <span class="type">List</span>[<span class="built_in">int</span>], D: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_min_days</span>(<span class="params">weights, cap</span>):</span></span><br><span class="line">        day, cur = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> weights:</span><br><span class="line">            <span class="keyword">if</span> cur + w &gt; cap:</span><br><span class="line">                day += <span class="number">1</span></span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">            cur += w</span><br><span class="line">        <span class="keyword">return</span> day   </span><br><span class="line">    </span><br><span class="line">    left = <span class="built_in">max</span>(weights)</span><br><span class="line">    right = <span class="built_in">sum</span>(weights)</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        day = get_min_days(weights, mid)</span><br><span class="line">        <span class="keyword">if</span> day &gt; D:</span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># load more each day</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure></p><h2 id="981-Time-Based-Key-Value-Store"><a href="#981-Time-Based-Key-Value-Store" class="headerlink" title="981. Time Based Key-Value Store"></a>981. Time Based Key-Value Store</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.keymap = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, key: <span class="built_in">str</span>, value: <span class="built_in">str</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.keymap[key].append((timestamp, value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">str</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.keymap:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        values = self.keymap[key]</span><br><span class="line">        <span class="keyword">if</span> timestamp &lt; values[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> timestamp &gt;= values[-<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> values[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># find right bound</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(values)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            stamp, value = values[mid]</span><br><span class="line">            <span class="keyword">if</span> stamp == timestamp:</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            <span class="keyword">elif</span> stamp &lt; timestamp:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> values[left - <span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Classic binary search scenarios are find a number, and find boundaries.&lt;br&gt;Leetcode Binary Search Problem Set (1) - Medium&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;278.First Bad Version&lt;/li&gt;
&lt;li&gt;33.Search in Rotated Sorted Array&lt;/li&gt;
&lt;li&gt;1283.Find the Smallest Divisor Given a Threshold&lt;/li&gt;
&lt;li&gt;875.Koko Eating Bananas&lt;/li&gt;
&lt;li&gt;1011.Capacity To Ship Packages Within D Days&lt;/li&gt;
&lt;li&gt;981.Time Based Key-Value Store</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Binary Search" scheme="http://testsiling.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Backtracking (2)</title>
    <link href="http://testsiling.github.io/2020/12/28/al-backtracking-2/"/>
    <id>http://testsiling.github.io/2020/12/28/al-backtracking-2/</id>
    <published>2020-12-28T16:19:32.000Z</published>
    <updated>2020-12-28T16:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode backtracking problem collection (2) - Hard</p><ul><li>51.N-Queens</li><li>37.Sudoku Solver</li></ul><span id="more"></span><h2 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a>51. N-Queens</h2><p>For this problem, the trickiest part for me is how to store diagonals.<br>check this <a href="https://www.youtube.com/watch?v=Xa-yETqFNEQ">video</a><br>use 2 array to index dale and hill diagonals, both length are <script type="math/tex">n * 2 - 1</script></p><p>Hill Diagonals: idx = row + col<br>0    1    2    3    4<br>1    2    3    4    5<br>2    3    4    5    6<br>3    4    5    6    7<br>4    5    6    7    8</p><p>Dale Diagonals: idx = row - col</p><p>0    -1    -2    -3    -4<br>1    0    -1    -2    -3<br>2    1    0    -1    -2<br>3    2    1    0    -1<br>4    3    2    1    0</p><p>Use <code>updateBoard(r, c, is_put)</code> to update private variables.<br>Bacause Python string cannot update element by index (need to slice), so store board in 2d array, then melt the array into string whtn solution found.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">available</span>(<span class="params">r, c</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> cols[c] <span class="keyword">and</span> <span class="keyword">not</span> dale[r - c] <span class="keyword">and</span> <span class="keyword">not</span> hill[r + c]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateBoard</span>(<span class="params">r, c, is_put</span>):</span></span><br><span class="line">        cols[c] = is_put</span><br><span class="line">        dale[r - c] = is_put</span><br><span class="line">        hill[r + c] = is_put</span><br><span class="line">        board[r][c] = <span class="string">&#x27;Q&#x27;</span> <span class="keyword">if</span> is_put <span class="keyword">else</span> <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getBoard</span>(<span class="params">board</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;&#x27;</span>.join(x) <span class="keyword">for</span> x <span class="keyword">in</span> board]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> r == n:</span><br><span class="line">            res.append(getBoard(board))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> available(r, c):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            updateBoard(r, c, <span class="number">1</span>)</span><br><span class="line">            backtrack(r + <span class="number">1</span>)</span><br><span class="line">            updateBoard(r, c, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    cols = [<span class="number">0</span>] * n</span><br><span class="line">    dale = [<span class="number">0</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">    hill = [<span class="number">0</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">    board = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    res = []</span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a>37. Sudoku Solver</h2><p>First, this one is really hard. Unlike the n-queen problem, indexing cubes is easy. But Desidning backtrack and how to end the track is pretty hard.<br>For indexing, I just assign an array from 0 - 9, 10 space to log the fill in number. Just ignore the 0.<br>For grids, draw it down on a paper then you will find in order to get</p><p>0, 1, 2,<br>3, 4, 5,<br>6, 7, 8</p><p>can be converted from</p><p>0, 1, 2<br>1, 2, 3<br>2, 3, 4</p><p>which is generate by <em>row // 3 + col // 3</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateBoard</span>(<span class="params">r, c, n, is_fill</span>):</span></span><br><span class="line">        board[r][c] = <span class="built_in">str</span>(n) <span class="keyword">if</span> is_fill <span class="keyword">else</span> <span class="string">&#x27;.&#x27;</span></span><br><span class="line">        rows[r][n] = is_fill</span><br><span class="line">        cols[c][n] = is_fill</span><br><span class="line">        grids[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][n] = is_fill</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">available</span>(<span class="params">r, c, n</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (rows[r][n] <span class="keyword">or</span> cols[c][n] <span class="keyword">or</span> grids[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][n])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">r, c</span>):</span></span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> backtrack(r + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> board[r][c] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> backtrack(r, c+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> available(r, c, n):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            updateBoard(r, c, n, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> backtrack(r, c + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            updateBoard(r, c, n, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    rows = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">    cols = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">    grids = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]  <span class="comment"># idx = row // 3 * 3 + col // 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># initial rows, cols, and grids</span></span><br><span class="line">    <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(board):</span><br><span class="line">        <span class="keyword">for</span> j, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">            <span class="keyword">if</span> n != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                updateBoard(i, j, <span class="built_in">int</span>(n), <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://zxi.mytechroad.com/blog/searching/leetcode-37-sudoku-solver/">http://zxi.mytechroad.com/blog/searching/leetcode-37-sudoku-solver/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode backtracking problem collection (2) - Hard&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;51.N-Queens&lt;/li&gt;
&lt;li&gt;37.Sudoku Solver&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Backtracking" scheme="http://testsiling.github.io/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Backtracking (1)</title>
    <link href="http://testsiling.github.io/2020/12/27/al-backtracking-1/"/>
    <id>http://testsiling.github.io/2020/12/27/al-backtracking-1/</id>
    <published>2020-12-27T15:46:12.000Z</published>
    <updated>2020-12-27T15:46:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Backtracking">Backtracking</a> is a general algorithm for finding all (or some) solutions to some computational problems.</p><p>Leetcode backtracking problem collection (1)</p><ul><li>46.Permutations</li><li>78.Subsets</li><li>77.Combinations</li><li>39.Combination Sum</li><li>22.Generate Parentheses<span id="more"></span></li></ul><h2 id="Difference-between-backtracking-and-DFS"><a href="#Difference-between-backtracking-and-DFS" class="headerlink" title="Difference between backtracking and DFS:"></a>Difference between backtracking and DFS:</h2><p>Backtracking is an algorithem, DFS is a specific form of backtracking related to searching tree structures.<br>DFS handles an explicit tree.While Backtracking handles an implicit tree.</p><h2 id="How-to-backtrack"><a href="#How-to-backtrack" class="headerlink" title="How to backtrack?"></a>How to backtrack?</h2><p>Backtracking actually is searching a decision tree. Three keys:</p><ol><li>path: decisions you made</li><li>choices: remaining options</li><li>terminal criteria: reach the end of decision tree.</li></ol><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">path, choices</span>):</span></span><br><span class="line">    <span class="keyword">if</span> terminal criteria:</span><br><span class="line">        res.append(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        make decision</span><br><span class="line">        backtracking(path, choices)</span><br><span class="line">        cancel choose</span><br></pre></td></tr></table></figure><h2 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h2><p>Technically backtracking is brute force, it will exhaust all possible solutions. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums, path</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="built_in">len</span>(path):</span><br><span class="line">            res.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> path:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            backtrack(nums, path + [n])</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    backtrack(nums, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h2><p>pre-order search.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, path</span>):</span></span><br><span class="line">        res.append(path)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">            backtrack(i + <span class="number">1</span>, path + [nums[i]])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    backtrack(<span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h2><p>The same as finding subsets, but only attach path when length hit k.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, path</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">            res.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n + <span class="number">1</span>):</span><br><span class="line">            backtrack(i + <span class="number">1</span>, path + [i])</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    backtrack(<span class="number">1</span>, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, path, cur</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cur &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> cur == target:</span><br><span class="line">            res.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">            n = nums[i]</span><br><span class="line">            backtrack(i, path + [n], cur + n)</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    backtrack(<span class="number">0</span>, [], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h2><p>use <code>left</code> and <code>right</code> to log reamining number of bracket. Remaining right should always greater or equal to left.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">left, right, path</span>):</span></span><br><span class="line">        <span class="comment"># right bracket should more than left</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; left <span class="keyword">or</span> left &lt; <span class="number">0</span> <span class="keyword">or</span> right &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> right == <span class="number">0</span> <span class="keyword">and</span> left == <span class="number">0</span>:</span><br><span class="line">            res.append(path)</span><br><span class="line">        backtrack(left - <span class="number">1</span>, right, path + <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        backtrack(left, right - <span class="number">1</span>, path + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    backtrack(n, n, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://stackoverflow.com/questions/1294720/whats-the-difference-between-backtracking-and-depth-first-search">https://stackoverflow.com/questions/1294720/whats-the-difference-between-backtracking-and-depth-first-search</a></li><li><a href="https://leetcode.com/discuss/general-discussion/136503/what-is-difference-between-backtracking-and-depth-first-search">https://leetcode.com/discuss/general-discussion/136503/what-is-difference-between-backtracking-and-depth-first-search</a></li><li><a href="https://en.wikipedia.org/wiki/Backtracking">https://en.wikipedia.org/wiki/Backtracking</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Backtracking&quot;&gt;Backtracking&lt;/a&gt; is a general algorithm for finding all (or some) solutions to some computational problems.&lt;/p&gt;
&lt;p&gt;Leetcode backtracking problem collection (1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;46.Permutations&lt;/li&gt;
&lt;li&gt;78.Subsets&lt;/li&gt;
&lt;li&gt;77.Combinations&lt;/li&gt;
&lt;li&gt;39.Combination Sum&lt;/li&gt;
&lt;li&gt;22.Generate Parentheses</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Backtracking" scheme="http://testsiling.github.io/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Tree (3)</title>
    <link href="http://testsiling.github.io/2020/12/26/al-tree-3/"/>
    <id>http://testsiling.github.io/2020/12/26/al-tree-3/</id>
    <published>2020-12-26T21:27:33.000Z</published>
    <updated>2020-12-26T21:27:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Tree problem collection (3)</p><ul><li>99.Recover Binary Search Tree</li><li>94.Binary Tree Inorder Traversal</li><li>116.Populating Next Right Pointers in Each Node</li><li>114.Flatten Binary Tree to Linked List</li><li>654.Maximum Binary Tree</li><li>106.Construct Binary Tree from Inorder and Postorder Traversal</li></ul><span id="more"></span><p>Inorder (Left, Root, Right)<br>Preorder (Root, Left, Right)<br>Postorder (Left, Right, Root)</p><h2 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99. Recover Binary Search Tree"></a>99. Recover Binary Search Tree</h2><p>In-order tranversal in a Binary Search Tree should get an ascending array. So when <script type="math/tex">Node_i < Node_{i-1}</script> means <script type="math/tex">Node_i</script> is the error node. It should swao with either <script type="math/tex">Node_{i-1}</script> or another error node if found.<br>x, y are pointers of error nodes, <em>pre</em> is used to log the previous node val. <em>node.val</em> shoule always less than <em>pre.val</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findError</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x, y, pre</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        findError(node.left)</span><br><span class="line">        <span class="keyword">if</span> pre <span class="keyword">and</span> node.val &lt; pre.val:</span><br><span class="line">            y = node</span><br><span class="line">            <span class="comment"># 1st error</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">                x = pre</span><br><span class="line">            <span class="comment"># 2nd error</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        pre = node</span><br><span class="line">        findError(node.right)</span><br><span class="line">    </span><br><span class="line">    x = y = pre = <span class="literal">None</span></span><br><span class="line">    findError(root)</span><br><span class="line">    x.val, y.val = y.val, x.val</span><br></pre></td></tr></table></figure></p><h2 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h2><p>Classic in-order search: left - root-right<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">nonlocal</span> res</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        traversal(root.left)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        traversal(root.right)</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    traversal(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a>116. Populating Next Right Pointers in Each Node</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># connect local left, right</span></span><br><span class="line">    <span class="keyword">if</span> root.left:</span><br><span class="line">        root.left.<span class="built_in">next</span> = root.right</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">and</span> root.<span class="built_in">next</span>:</span><br><span class="line">        root.right.<span class="built_in">next</span> = root.<span class="built_in">next</span>.left</span><br><span class="line">    self.connect(root.left)</span><br><span class="line">    self.connect(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="BFS-deque"><a href="#BFS-deque" class="headerlink" title="BFS / deque"></a>BFS / deque</h3><p>using Deque<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    q = deque([root])</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        size = <span class="built_in">len</span>(q)</span><br><span class="line">        <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> size &gt; <span class="number">1</span>: <span class="comment">## not the right most:</span></span><br><span class="line">                node.<span class="built_in">next</span> = q[<span class="number">0</span>]</span><br><span class="line">            size -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">                q.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p><p>Or BFS with improvement, get rid of the deque, use the next pointer.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    cur  = root</span><br><span class="line">    <span class="built_in">next</span> = root.left</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">next</span> :</span><br><span class="line">        cur.left.<span class="built_in">next</span> = cur.right</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># not the right-most node</span></span><br><span class="line">        <span class="keyword">if</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            cur.right.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.left</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># go to the next level</span></span><br><span class="line">            <span class="comment"># start from the left most element</span></span><br><span class="line">            cur = <span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span> = cur.left</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p><h2 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a>114. Flatten Binary Tree to Linked List</h2><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><p>post-order, flatten left, then flatten right, move left child to right and append the original right child to the end of new right child<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self.flatten(root.left)</span><br><span class="line">    self.flatten(root.right)</span><br><span class="line">    </span><br><span class="line">    right = root.right</span><br><span class="line">    left = root.left</span><br><span class="line">    </span><br><span class="line">    root.left = <span class="literal">None</span></span><br><span class="line">    root.right = left</span><br><span class="line">    </span><br><span class="line">    p = root</span><br><span class="line">    <span class="keyword">while</span> p.right:</span><br><span class="line">        p = p.right</span><br><span class="line">    p.right = right</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p><h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> root:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># find rightest element</span></span><br><span class="line">            p = root.left</span><br><span class="line">            <span class="keyword">while</span> p.right:</span><br><span class="line">                p = p.right</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># move right child to left.right</span></span><br><span class="line">            p.right = root.right</span><br><span class="line">            <span class="comment"># move left child to right</span></span><br><span class="line">            root.right = root.left</span><br><span class="line">            root.left = <span class="literal">None</span></span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure><h2 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a>654. Maximum Binary Tree</h2><p>Classic recursion<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    val = <span class="built_in">max</span>(nums)</span><br><span class="line">    i = nums.index(val)</span><br><span class="line">    root = TreeNode(val)</span><br><span class="line">    root.left = self.constructMaximumBinaryTree(nums[:i])</span><br><span class="line">    root.right = self.constructMaximumBinaryTree(nums[i + <span class="number">1</span>: ])</span><br><span class="line">    <span class="keyword">return</span> root  </span><br></pre></td></tr></table></figure></p><h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h2><p>Pretty straightforward solution, but not the best!<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    val = postorder[-<span class="number">1</span>]</span><br><span class="line">    root = TreeNode(val)</span><br><span class="line">    </span><br><span class="line">    i = inorder.index(val)</span><br><span class="line">    in_left = inorder[:i]</span><br><span class="line">    in_right = inorder[i + <span class="number">1</span>:]</span><br><span class="line">    </span><br><span class="line">    post_left = postorder[:<span class="built_in">len</span>(in_left)]</span><br><span class="line">    post_right = postorder[<span class="built_in">len</span>(in_left): -<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    root.left = self.buildTree(in_left, post_left)</span><br><span class="line">    root.right = self.buildTree(in_right, post_right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><br>Finding index is O(n). Slicing array is O(k), k = slicing size. And extra space. Overall time and extra space is O(n^2)<br>So, to avoid finding index and slicing, use hash map<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        </span><br><span class="line">    dic = &#123;v: i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">lo, hi</span>):</span></span><br><span class="line">        <span class="keyword">if</span> lo &gt; hi:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = TreeNode(postorder.pop())</span><br><span class="line">        i = dic[node.val]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># poping from post order, so should construct right child first</span></span><br><span class="line">        node.right = build(i + <span class="number">1</span>, hi)</span><br><span class="line">        node.left = build(lo, i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>And LC105 can be imporved in similar way.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Tree problem collection (3)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;99.Recover Binary Search Tree&lt;/li&gt;
&lt;li&gt;94.Binary Tree Inorder Traversal&lt;/li&gt;
&lt;li&gt;116.Populating Next Right Pointers in Each Node&lt;/li&gt;
&lt;li&gt;114.Flatten Binary Tree to Linked List&lt;/li&gt;
&lt;li&gt;654.Maximum Binary Tree&lt;/li&gt;
&lt;li&gt;106.Construct Binary Tree from Inorder and Postorder Traversal&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Data Structure" scheme="http://testsiling.github.io/tags/Data-Structure/"/>
    
    <category term="Tree" scheme="http://testsiling.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Data Structure Cheat Sheet</title>
    <link href="http://testsiling.github.io/2020/12/26/data-strcture-cheatsheet/"/>
    <id>http://testsiling.github.io/2020/12/26/data-strcture-cheatsheet/</id>
    <published>2020-12-26T19:40:42.000Z</published>
    <updated>2020-12-26T19:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Basically, there’re two ways to store data strctures: <strong>array</strong> and <strong>linked list</strong>.<br>All other data strctures, such as queue, stack, graph, hashmap, tree, heap, etc, all can be implemented by array and linked list.</p><span id="more"></span><p>In python, <strong>list = array</strong> is implemented by dynamic array, when it used up the original assigned space, it will point to new sapce.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t ob_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */</span></span><br><span class="line">    PyObject **ob_item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ob_item contains space for &#x27;allocated&#x27; elements.  The number</span></span><br><span class="line"><span class="comment">     * currently in use is ob_size.</span></span><br><span class="line"><span class="comment">     * Invariants:</span></span><br><span class="line"><span class="comment">     *     0 &lt;= ob_size &lt;= allocated</span></span><br><span class="line"><span class="comment">     *     len(list) == ob_size</span></span><br><span class="line"><span class="comment">     *     ob_item == NULL implies ob_size == allocated == 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure><p>The array itself stores a list of of pointers. Therefore, while using list, need to cautious to some traps like: during initialization, all pointers are pointing to the same list<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls = [[]] * <span class="number">5</span></span><br><span class="line">ls[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(ls)  <span class="comment">#[[1], [1], [1], [1], [1]]</span></span><br></pre></td></tr></table></figure><br>Also, time for popping the last element is O(1), but popping intermediate is O(n). </p><h2 id="Tranverseal"><a href="#Tranverseal" class="headerlink" title="Tranverseal"></a>Tranverseal</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><h3 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># iterative</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tranverse</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">        <span class="comment"># do something</span></span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># recursive</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tranverse</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    tranverse(head.<span class="built_in">next</span>)</span><br></pre></td></tr></table></figure><h3 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tranverse</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># pre-order</span></span><br><span class="line">    tranverse(root.left)</span><br><span class="line">    <span class="comment"># in-order</span></span><br><span class="line">    tranverse(root.right)</span><br><span class="line">    <span class="comment"># post-order</span></span><br></pre></td></tr></table></figure><h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice:"></a>Practice:</h3><ul><li>124.Binary Tree Maximum Path Sum</li><li>105.Construct Binary Tree from Preorder and Inorder Traversal</li><li>94.Binary Tree Inorder Traversal</li><li>106.Construct Binary Tree from Inorder and Postorder Traversal</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Basically, there’re two ways to store data strctures: &lt;strong&gt;array&lt;/strong&gt; and &lt;strong&gt;linked list&lt;/strong&gt;.&lt;br&gt;All other data strctures, such as queue, stack, graph, hashmap, tree, heap, etc, all can be implemented by array and linked list.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Data Structure" scheme="http://testsiling.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Stack (1)</title>
    <link href="http://testsiling.github.io/2020/12/16/al-stack-1/"/>
    <id>http://testsiling.github.io/2020/12/16/al-stack-1/</id>
    <published>2020-12-17T03:06:09.000Z</published>
    <updated>2020-12-17T03:06:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Stack Problem Collection (1)</p><ul><li>20.Valid Parentheses</li><li>1249.Minimum Remove to Make Valid Parentheses</li><li>394.Decode String</li><li>1209.Remove All Adjacent Duplicates in String II</li><li>739.Daily Temperatures</li><li><ol><li>Simplify Path</li></ol></li></ul><span id="more"></span><h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    right = &#123;</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="comment"># left bracket</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> right:</span><br><span class="line">            stack.append(c)</span><br><span class="line">        <span class="comment"># right bracket</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack.pop() != right[c]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><h2 id="1249-Minimum-Remove-to-Make-Valid-Parentheses"><a href="#1249-Minimum-Remove-to-Make-Valid-Parentheses" class="headerlink" title="1249. Minimum Remove to Make Valid Parentheses"></a>1249. Minimum Remove to Make Valid Parentheses</h2><ul><li>for right bracket, must match to an existed left bracket, or remove it.</li><li>for left bracket, log its index<br>After scan the whole string, remove open left bracket<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    open_left = []</span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            res += c</span><br><span class="line">            open_left.append(<span class="built_in">len</span>(res) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> open_left:</span><br><span class="line">                res += c</span><br><span class="line">                open_left.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += c</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(open_left):</span><br><span class="line">        res = res[:i] + res[i + <span class="number">1</span>: ]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ul><h2 id="394-Decode-String"><a href="#394-Decode-String" class="headerlink" title="394. Decode String"></a>394. Decode String</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decodeString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            repeat = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                x = stack.pop()</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># found substring</span></span><br><span class="line">                <span class="keyword">if</span> x == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                    <span class="comment"># find number</span></span><br><span class="line">                    num = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                    <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>].isdigit():</span><br><span class="line">                        num = stack.pop() + num</span><br><span class="line">                    num = <span class="built_in">int</span>(num)</span><br><span class="line">                    repeat = repeat * <span class="built_in">int</span>(num)</span><br><span class="line">                    stack.append(repeat)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                repeat = x + repeat</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(c)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure><h2 id="1209-Remove-All-Adjacent-Duplicates-in-String-II"><a href="#1209-Remove-All-Adjacent-Duplicates-in-String-II" class="headerlink" title="1209. Remove All Adjacent Duplicates in String II"></a>1209. Remove All Adjacent Duplicates in String II</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    stack = []  <span class="comment"># (element, cnt)</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">and</span> c == stack[-<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">            cnt = stack[-<span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            stack.append((c, cnt))</span><br><span class="line">            <span class="keyword">if</span> cnt == k:</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                    stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append((c, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> stack])</span><br></pre></td></tr></table></figure><h2 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739. Daily Temperatures"></a>739. Daily Temperatures</h2><p>use index to calculate days<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, T: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    stack = []  <span class="comment"># temp, index</span></span><br><span class="line">    warmer = [<span class="number">0</span>] * <span class="built_in">len</span>(T)</span><br><span class="line">    <span class="keyword">for</span> i, temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(T):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> temp &gt; stack[-<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">            pre_temp, j = stack.pop()</span><br><span class="line">            warmer[j] = i - j</span><br><span class="line">        stack.append((temp, i))</span><br><span class="line">    <span class="keyword">return</span> warmer</span><br></pre></td></tr></table></figure></p><h2 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71. Simplify Path"></a>71. Simplify Path</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">self, path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    paths = path.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> paths:</span><br><span class="line">        <span class="keyword">if</span> p == <span class="string">&#x27;..&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> p == <span class="string">&#x27;.&#x27;</span> <span class="keyword">or</span> p == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(p)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;/&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Stack Problem Collection (1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;20.Valid Parentheses&lt;/li&gt;
&lt;li&gt;1249.Minimum Remove to Make Valid Parentheses&lt;/li&gt;
&lt;li&gt;394.Decode String&lt;/li&gt;
&lt;li&gt;1209.Remove All Adjacent Duplicates in String II&lt;/li&gt;
&lt;li&gt;739.Daily Temperatures&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Simplify Path&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://testsiling.github.io/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm - Dynamic Programming (1)</title>
    <link href="http://testsiling.github.io/2020/12/14/al-dp-1/"/>
    <id>http://testsiling.github.io/2020/12/14/al-dp-1/</id>
    <published>2020-12-15T01:30:55.000Z</published>
    <updated>2020-12-15T01:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode Dynamic Programming Problem Collection (1)</p><p>Green hand in DP problem<br>The key of Dynamic Programming is to get local result, then get global result. </p><ul><li>70.Climbing Stairs</li><li>121.Best Time to Buy and Sell Stock *</li><li>53.Maximum Subarray</li><li>198.House Robber</li><li>746.Min Cost Climbing Stairs</li><li>42.Trapping Rain Water</li></ul><span id="more"></span><h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h2><script type="math/tex; mode=display">step_i = step_{i-1} + step_{i-2}</script><p>Tried to use recursion but it was super slow. Use iteration is much faster.</p><p>calculate the previous step 1 and step 2, keep tracking it. Time = O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">    p1, p2 = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">        cur = p1 + p2</span><br><span class="line">        p1, p2 = p2, cur</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h2><p>I like this one. logging the lowest buying price while updating max profit<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    lowest = prices[<span class="number">0</span>]</span><br><span class="line">    profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">        lowest = <span class="built_in">min</span>(lowest, price)</span><br><span class="line">        profit = <span class="built_in">max</span>(profit, price - lowest)</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure></p><h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h2><h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><p>find local max sum, update global max sum if greater.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    max_sum = nums[<span class="number">0</span>]</span><br><span class="line">    cur_sum = nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        cur_sum = <span class="built_in">max</span>(cur_sum + num, num)</span><br><span class="line">        max_sum = <span class="built_in">max</span>(cur_sum, max_sum)</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure></p><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums)</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + num, num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><h2 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums, default=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    gain = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    gain[<span class="number">0</span>], gain[<span class="number">1</span>] = nums[<span class="number">0</span>], <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># Two options:</span></span><br><span class="line">        <span class="comment"># 1) rob it, gain(i) = gain(i-2) + current money</span></span><br><span class="line">        <span class="comment"># 2) don&#x27;t rob it, current max gain is gain(i - 1)</span></span><br><span class="line">        gain[i] = <span class="built_in">max</span>(gain[i - <span class="number">2</span>] + nums[i], gain[i - <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gain[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="746-Min-Cost-Climbing-Stairs"><a href="#746-Min-Cost-Climbing-Stairs" class="headerlink" title="746. Min Cost Climbing Stairs"></a>746. Min Cost Climbing Stairs</h2><p>Either pay the last step, or pay the second last step<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    s0, s1 = cost[<span class="number">0</span>], cost[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(cost)):</span><br><span class="line">        s1, s0 = <span class="built_in">min</span>(cost[i] + s0, cost[i] + s1), s1</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(s0, s1)</span><br></pre></td></tr></table></figure></p><h2 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h2><p>DP solution, log left max, then log right max<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(height) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    left_max, right_max = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># left, right, rain</span></span><br><span class="line">    dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(height))]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># find left max:</span></span><br><span class="line">    <span class="keyword">for</span> i, h <span class="keyword">in</span> <span class="built_in">enumerate</span>(height):</span><br><span class="line">        dp[i][<span class="number">0</span>] = left_max</span><br><span class="line">        left_max = <span class="built_in">max</span>(h, left_max)</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="comment"># find right max, calculate rain</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(height) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">1</span>] = right_max</span><br><span class="line">        right_max = <span class="built_in">max</span>(right_max, height[i])</span><br><span class="line">        res += <span class="built_in">max</span>(<span class="built_in">min</span>(dp[i][<span class="number">0</span>], dp[i][<span class="number">1</span>]) - height[i], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><br>It also has a stack solution.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode Dynamic Programming Problem Collection (1)&lt;/p&gt;
&lt;p&gt;Green hand in DP problem&lt;br&gt;The key of Dynamic Programming is to get local result, then get global result. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;70.Climbing Stairs&lt;/li&gt;
&lt;li&gt;121.Best Time to Buy and Sell Stock *&lt;/li&gt;
&lt;li&gt;53.Maximum Subarray&lt;/li&gt;
&lt;li&gt;198.House Robber&lt;/li&gt;
&lt;li&gt;746.Min Cost Climbing Stairs&lt;/li&gt;
&lt;li&gt;42.Trapping Rain Water&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="http://testsiling.github.io/tags/Algorithm/"/>
    
    <category term="Python" scheme="http://testsiling.github.io/tags/Python/"/>
    
    <category term="Leetcode" scheme="http://testsiling.github.io/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://testsiling.github.io/tags/Dynamic-Programming/"/>
    
    <category term="Greedy" scheme="http://testsiling.github.io/tags/Greedy/"/>
    
  </entry>
  
</feed>
